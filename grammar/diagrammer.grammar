/*https://github.com/zaach/jison/wiki/Deviations-From-Flex-Bison*/
%start S
%ebnf
%{
	//generators = new Map();
	//visualizations = new Map();
	// there seems to be NO way to autoinitialize GraphCanvas
	// this section is totally disconnected from the parser and has no access to yy
	// lexer has yy access to is disconnected from here, no matter what you try..
	// having simple accessible (global to ) parser variable like
	// const graphcanvas=new GraphCanvas() doesn't work...
	// nor yy.graphcanvas = new GraphCanvas()
	// Some hacks towards that, but not really functional...
	// https://stackoverflow.com/questions/30562134/jison-global-variables
	// Basically ONLY way to get this done is to pass from above,ie.
	// anytime doing parsing,
	// diagrammer.parser.yy.GRAPHCANVAS = new GraphCanvas();
	// diagrammer.parser.parse(code);
	// https://gerhobbelt.github.io/jison/docs/#specifying-a-language
%}
%%
S
	: graphContent			-> $graphContent
	| S graphContent		-> $S + $graphContent
	| S EOF
		{
			/*	- caller can ALWAYS specify the generator
				- caller can ALWAYS specify the visualizer
				- only graphviz has multiple visualizer (currently it 
				  only draws digraphs, but those can be visualized with dot, neato.circo etc)
				- generator/visualizer(since different grammars)
					- mscgen=mscgen
					- seqdiag=seqdiag
					- blockdiag=blockdiag
					- nwdiag=nwdiag
					- ast=ast
					- plantuml_sequence=plantuml_sequence

					PlantUML MIGHT BE plantuml/[sequence|activty etc.]
				- If visualizer given, RECORD it, do not use...
				- Caller can then (willingly) check for LANGUAGE given visualizer(or generator) and
				  override those or obey to those. Those would be suggested tools to use...
			*/

			// Generator can be defined by the caller(user) or suggested by the graph
			const graphcanvas = yy.GRAPHCANVAS;
			const parsedGenerator = graphcanvas.getGenerator();
			const parsedVisualizer = graphcanvas.getVisualizer();
			// TODO: Simplify, pass back to the caller, let it do decision what to use
			// THIS special feature is only used with web UI, so makes more sense than complicated BL here..
			if (yy.parsedGeneratorAndVisualizer) {
			  yy.parsedGeneratorAndVisualizer(parsedGenerator, parsedVisualizer, yy.PREFER_GENERATOR_VISUALIZER_FROM_DIAGRAMMER);
			}

			if (yy.PREFER_GENERATOR_VISUALIZER_FROM_DIAGRAMMER) {
			  debug('Called wants to prefer generator/parser from the script');
			  if (parsedGenerator) {
			    const foundGeneratorFunc = generators.get(parsedGenerator);
			    if (foundGeneratorFunc) {
			      // We're asked to prefer script generator and such generator exists
			      yy.USE_GENERATOR = parsedGenerator;
			      debug(`Using found and recognized parsed generator (${parsedGenerator})`);
			    }
			  }
			  if (parsedVisualizer) {
			    const useVisualizerFunc = visualizations.get(parsedVisualizer);
			    if (useVisualizerFunc) {
			      // Found visualizer and recognized it
			      // TODO: NO support for this yet...
			    }
			  }
			}

			if (yy.USE_GENERATOR) {
			  graphcanvas.setGenerator(yy.USE_GENERATOR);
			}

			// Visualizer can be defined by the caller(user) or suggested by the graph
			if (yy.USE_VISUALIZER) {
			  graphcanvas.setVisualizer(yy.USE_VISUALIZER);
			} else if (!graphcanvas.getVisualizer()) {
			  const visualizer = graphcanvas.getVisualizer();
			  if (visualizer == "digraph") {
			    graphcanvas.setVisualizer("dot");
			  } else {
			    graphcanvas.setVisualizer(graphcanvas.getGenerator());
			  }
			}
			graphcanvas.parseError = yy.parseError;
			graphcanvas.result = yy.result;
			//graphcanvas.yy = yy;
			
			// Locate the generator, else just use digraph
			const usegen = generators.get(graphcanvas.getGenerator());
			if (usegen) {
				usegen(graphcanvas);
			} else {
				console.log("Available generators:");
				for (const key of generators.keys()) {
  					console.log(key);
				}
				throw new Error(`Unknown generator ${graphcanvas.getGenerator()}`);
			}
			return $1;
		}
	;

/* Read a color #xxxxxx or a variable $(xxx) or $(xxx:yyy) that MUST produce #xxxxxx*/
colorOrVariable
	: COLOR		-> $COLOR
	| VARIABLE	-> _processVariable(yy.GRAPHCANVAS, $VARIABLE) /*one can use named $VARIABLE or positional $1 args, like former, but latter seem more ...readable*/
	;

/* Read a shape  or a variable $(xxx) or $(xxx:yyy) that MUST produce a shape */
shapeOrVariable
	: VARIABLE {
			$$=_processVariable(yy.GRAPHCANVAS, $1).trim().toLowerCase();
			if (["actor", "beginpoint", "box", "circle", "cloud", "condition", "database", "default", "diamond", "dots", "doublecircle",
				 "ellipse", "endpoint", "input", "loopin", "loopout", "mail", "minidiamond", "minisquare", "note", "record", "roundedbox",
				 "square", "terminator", "loop", "loopend", "loopstart", "rect", "rectangle"].indexOf($$)==-1){
				throw new Error("Must use declared shape");
			}
	}
	| SHAPES -> $SHAPES
	;

/* read vertice's attributes basically like: [STYLES] [SHAPES] NAME [IMAGE|COLOR]*/
readVertexAttrs
    /*  1      2       3       4        5            6          7*/
	: STYLES? SHAPES? NAME COMPASS? colorOrVariable? IMAGE? -> _getVertex(yy.GRAPHCANVAS, $NAME, $1).setColor($5);if ($$ instanceof GraphVertex) setAttr($$.setShape($2).setImage($6), 'compass', $4)
	;

/*
NOT BEST...return GraphVertex or Group, but some commands allow only GraphVertex and some just Group...
But it gets thing done..for now!
TODO: Fix it

This means _getVertex MUST be able to return a Group as well! If name matches!!

left recursive
  X=[STYLES] [SHAPES] NAME [IMAGE|COLOR]
  X ([ LISTSEP X]*)
See Cris Dodds good explanation of right recursion 
http://stackoverflow.com/questions/12715961/grammar-spec-resolving-shift-reduce-conflicts
And even better thorough explanation from IBM
http://publib.boulder.ibm.com/infocenter/zvm/v5r4/index.jsp?topic=/com.ibm.zvm.v54.dmsp4/hcsp4b10120.htm
vertexGroupListOrAttrs cumulates an array of vertices, RHS is the latest GraphVertex
*/
vertexGroupListOrAttrs
	: OPAREN -> _enterSubGraph(yy.GRAPHCANVAS)
	| vertexGroupListOrAttrs LISTSEP INLINE_STRING? readVertexAttrs -> _getList(yy.GRAPHCANVAS, $vertexGroupListOrAttrs, $readVertexAttrs, $3)
	| readVertexAttrs -> $readVertexAttrs
	| CPAREN -> _exitSubGraph(yy.GRAPHCANVAS)
	;
	/* TOOD: Could concatenate $4, $6 or if $4 defined AND $6, $6 could be appended as ::, unless already(note)*/
readEvents
        /*   1         2       3       4        5               6              7                   8*/
	: readEvents COMPASS? EVENT COMPASS? colorOrVariable? INLINE_STRING? vertexGroupListOrAttrs LABEL? -> _getEdge(yy.GRAPHCANVAS, $EVENT, $readEvents, $vertexGroupListOrAttrs, $6, $8?$8.substring(1):$8, $5, $2, $4).right
	| readEvents LABEL -> $$.setLabel($LABEL.substring(1))
	| vertexGroupListOrAttrs
	;

graphContent
	: VARIABLE -> _processVariable(yy.GRAPHCANVAS, $1)
	| SHAPE shapeOrVariable
		{
			debug("SHAPE getShapeOrVariablleee ");
			if ($2=="default") $2=undefined;
			$$=yy.GRAPHCANVAS.setCurrentShape($2);
		}
	| EQUAL vertexGroupListOrAttrs
		{
			_getCurrentContainer(yy.GRAPHCANVAS).setEqual($2 instanceof GraphVertex?new Array($2):$2);
		}
	| SHAPE NAME {throw new Error("Expecting one of the shapes, got ("+$2+")");}
	| LANDSCAPE		    -> yy.GRAPHCANVAS.setDirection("landscape")
	| GENERATOR NAME	-> yy.GRAPHCANVAS.setGenerator($NAME)
	| VISUALIZER NAME	-> yy.GRAPHCANVAS.setVisualizer($NAME)
	| PORTRAIT			-> yy.GRAPHCANVAS.setDirection("portrait")
	| COMMENT			-> "/*"+$COMMENT.substring(2)+"*/\n"
	| VERTEX_COLOR colorOrVariable	   -> _getCurrentContainer(yy.GRAPHCANVAS).setDefault('vertexcolor'    ,$2=="default"?undefined:$2)
	| VERTEXTEXT_COLOR colorOrVariable -> _getCurrentContainer(yy.GRAPHCANVAS).setDefault('vertextextcolor',$2=="default"?undefined:$2)
	| EDGE_COLOR colorOrVariable	   -> _getCurrentContainer(yy.GRAPHCANVAS).setDefault('edgecolor'      ,$2=="default"?undefined:$2)
	| EDGETEXT_COLOR colorOrVariable   -> _getCurrentContainer(yy.GRAPHCANVAS).setDefault('edgetextcolor'  ,$2=="default"?undefined:$2)
	| GROUP_COLOR colorOrVariable	   -> _getCurrentContainer(yy.GRAPHCANVAS).setDefault('groupcolor'     ,$2=="default"?undefined:$2)
	| IF	 ->	setAttr(setAttr(_enterContainer(yy.GRAPHCANVAS, _getGroup(yy.GRAPHCANVAS).setLabel($IF.replace(/\s+then\s*$/, "").replace(/^\s*if\s*/, ""))), 'conditional', 'if'), '_conditionalEntryEdge', yy.GRAPHCANVAS.lastSeenVertex)
	| ELSEIF {
		_exitContainer(yy.GRAPHCANVAS);
		$$=setAttr(_enterContainer(yy.GRAPHCANVAS, _getGroup(yy.GRAPHCANVAS).setLabel($ELSEIF.replace(/\s+then\s*$/, "").replace(/^\s*elseif\s*/, ""))), 'conditional', 'elseif')
		}
	| ELSE	 {
		_exitContainer(yy.GRAPHCANVAS);
		$$=setAttr(_enterContainer(yy.GRAPHCANVAS, _getGroup(yy.GRAPHCANVAS).setLabel($ELSE)), 'conditional', 'else')
		}
	| ENDIF	 { 
		_exitContainer(yy.GRAPHCANVAS);
		// TODO: is ENDIF container necessary?YES, it could be invisible vertex! Could link to that instead of endif kludge in digraph
		yy.GRAPHCANVAS._nextConnectableToExitEndIf=setAttr(_enterContainer(yy.GRAPHCANVAS, _getGroup(yy.GRAPHCANVAS).setLabel($ENDIF)), 'conditional', 'endif')
		debug("XXXXXXXXXXXXXXXXXXXXX _nextConnectableToExitEndIf"+yy.GRAPHCANVAS._nextConnectableToExitEndIf);
		$$=_exitContainer(yy.GRAPHCANVAS)
	}
	/* A GROUP declaration: GROUP [NAME] [COLOR] [LABEL] */
	| GROUP GROUPNAME? colorOrVariable? LABEL? GROUP_DECLARATION_END -> _enterContainer(yy.GRAPHCANVAS, _getGroup(yy.GRAPHCANVAS).setName($2).setColor($3).setLabel($4==undefined?undefined:$4.substring(1)))
	| GROUP_END  -> _exitContainer(yy.GRAPHCANVAS)
	| START NAME -> yy.GRAPHCANVAS.setStart($NAME)
	| readEvents {
	}
	;
%% 
