/*https://github.com/zaach/jison/wiki/Deviations-From-Flex-Bison*/
%start S
%ebnf
%%

S
	: contents EOF
		{
			/* 	- caller can ALWAYS specify the generator
				- caller can ALWAYS specify the visualizer
				- only graphviz has multiple visualizer (currently it 
				  only draws digraphs, but those can be visualized with dot, neato.circo etc)
				- generator/visualizer(since different grammars)
					- mscgen=mscgen
					- seqdiag=seqdiag
					- blockdiag=blockdiag
					- nwdiag=nwdiag
					- ast=ast
					- plantuml_sequence=plantuml_sequence

					PlantUML MIGHT BE plantuml/[sequence|activty etc.]
				- If visualizer given, RECORD it, do not use...
				- Caller can then (willingly) check for LANGUAGE given visualizer(or generator) and
				  override those or obey to those. Those would be suggested tools to use...
			*/
			var generator=getGraphRoot(yy).getGenerator();
			if (yy.OUTPUT)
			  generator=yy.OUTPUT;
			if (!yy.OUTPUT)
			  yy.OUTPUT=generator;
			if (!yy.VISUALIZER)
			  yy.VISUALIZER=getGraphRoot(yy).getVisualizer();
			if (!yy.VISUALIZER){
			  if( generator=="digraph")
			    yy.VISUALIZER="dot";
		  	  else
			    yy.VISUALIZER=generator;
			}
			if ("ast" == generator){
				ast(yy);
			}else if ("actdiag" == generator){
				actdiag(yy);
			}else if ("blockdiag" == generator){
				blockdiag(yy);
			}else if ("nwdiag" == generator){
				nwdiag(yy);
			}else if ("seqdiag" == generator){
				seqdiag(yy);
			}else if ("mscgen" == generator){
				mscgen(yy);
			}else if ("plantuml_sequence" == generator){
				plantuml_sequence(yy);
			}else{
				//rankdir available ONLY IN dot
				digraph(yy);
			}
			return $1;
		}
	;

contents
	: content 			-> $content
	| contents content 	-> $contents + $content
	;
/* Read a color #xxxxxx or a variable $(xxx) or $(xxx:yyy) that MUST produce #xxxxxx*/
colorOrVariable
	: VARIABLE 	-> processVariable(yy,$VARIABLE) /*one can use named $VARIABLE or positional $1 args, like former, but latter seem more ...readable*/
	| COLOR		-> $COLOR
	;

/* Read a shape  or a variable $(xxx) or $(xxx:yyy) that MUST produce a shape */
shapeOrVariable
	: VARIABLE {
			$$=processVariable(yy,$1).trim();
			if (["actor","beginpoint","box","circle","cloud","condition","database","default","diamond","dots","doublecircle","ellipse","endpoint","input","loopin","loopout","mail","minidiamond","minisquare","note","record","roundedbox","square","terminator","loop","loopend","loopstart","rect","rectangle"].indexOf($$)==-1){
				throw new Error("Must use declared shape");
			}
	}
	| SHAPES -> $SHAPES
	;

/* read nodes attributes basically like:
[STYLES] [SHAPES] NAME [IMAGE|COLOR]
Those few first ones are used with EVENTS
*/
readNodeAttrs
	: STYLES SHAPES NAME colorOrVariable? -> getNode(yy,$NAME,$STYLES).setColor($4).setShape($SHAPES)
	| STYLES NAME colorOrVariable?	-> getNode(yy,$NAME,$STYLES).setColor($3)
	| STYLES NAME IMAGE 			-> getNode(yy,$NAME,$STYLES).setImage($IMAGE)
	| SHAPES NAME colorOrVariable?	-> getNode(yy,$NAME).setColor($3).setShape($SHAPES)
	| NAME colorOrVariable?		 	-> getNode(yy,$NAME).setColor($2)
	| NAME IMAGE 					-> getNode(yy,$NAME).setImage($IMAGE)
	;

/*
NOT BEST...return Node or Group, but some commands allow only Node and some just Group...
But it gets thing done..for now!
TODO: Fix it

This means getNode MUST be able to return a Group as well! If name matches!!

left recursive
  X=[STYLES] [SHAPES] NAME [IMAGE|COLOR]
  X ([ LISTSEP X]*)
See Cris Dodds good explanation of right recursion 
http://stackoverflow.com/questions/12715961/grammar-spec-resolving-shift-reduce-conflicts
nodeGroupListOrAttrs cumulates an array of nodes, RHS is latest node
*/
nodeGroupListOrAttrs
	: nodeGroupListOrAttrs LISTSEP INLINE_STRING? readNodeAttrs -> getList(yy,$nodeGroupListOrAttrs,$readNodeAttrs,$3)
	| readNodeAttrs -> $readNodeAttrs
	;
/*
(nodeGroupListOrAttrs (LABEL|nodesAndEvents EVENT [colorOrVariable] [INLINE_STRING]))+
a>b
a#ff0000>#00ff00b#0000ff
color binds to left, always? Hmm..yes..and color variable as well, but sometimes variable binds to right(shape of node)
STYLES always bind to right
*/
nodesAndEvents
	: nodesAndEvents EVENT colorOrVariable INLINE_STRING nodeGroupListOrAttrs -> getLink(yy,$EVENT,$nodesAndEvents,$nodeGroupListOrAttrs,$INLINE_STRING,$colorOrVariable).right
	| nodesAndEvents EVENT colorOrVariable nodeGroupListOrAttrs LABEL? 	-> getLink(yy,$EVENT,$nodesAndEvents,$nodeGroupListOrAttrs,$5==undefined?undefined:$5.substring(1),$colorOrVariable).right
	| nodesAndEvents EVENT nodeGroupListOrAttrs LABEL
		{
			debug("nodesAndEvents EVENT nodeGroupListOrAttrs LABEL"+" SS="+$$+",S0="+$0+",S1="+$1+",S2="+$2+",S3="+$3);
			if ($3 instanceof Group){
				$$=getLink(yy,$2,$1,getGroup(yy,$3),$4.substring(1)).right;
			}else{
				$$=getLink(yy,$2,$1,getNode(yy,$3),$4.substring(1)).right;
			}
		}
	| nodesAndEvents EVENT INLINE_STRING nodeGroupListOrAttrs
		{
			if ($nodeGroupListOrAttrs instanceof Group){
				$$=getLink(yy,$EVENT,$nodesAndEvents,getGroup(yy,$nodeGroupListOrAttrs),$INLINE_STRING).right;
			}else{
				$$=getLink(yy,$EVENT,$nodesAndEvents,getNode(yy,$nodeGroupListOrAttrs),$INLINE_STRING).right;
			}
		}
	| nodesAndEvents EVENT nodeGroupListOrAttrs
		{
			if ($nodeGroupListOrAttrs instanceof Group){
				$$=getLink(yy,$EVENT,$nodesAndEvents,getGroup(yy,$nodeGroupListOrAttrs)).right;
			}else{
				$$=getLink(yy,$EVENT,$nodesAndEvents,getNode(yy,$nodeGroupListOrAttrs)).right;
			}
		}
	| nodeGroupListOrAttrs LABEL -> $$.setLabel($2.substring(1))
	| nodeGroupListOrAttrs {
			debug("nodeGroupListOrAttrs"+" SS="+$$+",S0="+$0+",S1="+$1);
		}
	;
	/*
	A GROUP declaration
	GROUP [NAME] [COLOR] [LABEL]
	*/
groupTarget
	: NAME? colorOrVariable? LABEL? -> enterContainer(yy,getGroup(yy).setName($1).setColor($2).setLabel($3==undefined?undefined:$3.substring(1)))
	;

content
	/* variable declaration(s) */
	: VARIABLE -> processVariable(yy,$1)
	/* set default shape*/
	| SHAPE shapeOrVariable
		{
			debug("SHAPE getShapeOrVariablleee ");
			if ($2=="default") $2=undefined;
			$$=getGraphRoot(yy).setCurrentShape($2);
		}
	/* set equal nodes */
	| EQUAL nodeGroupListOrAttrs
		{
			getCurrentContainer(yy).setEqual($2 instanceof Node?new Array($2):$2);
		}
	| SHAPE NAME {throw new Error("Expecting one of the shapes, got ("+$2+")");}
	/*other defaults*/
	| LANDSCAPE 		-> getGraphRoot(yy).setDirection("landscape")
	| GENERATOR NAME 	-> getGraphRoot(yy).setGenerator($NAME)
	| VISUALIZER NAME 	-> getGraphRoot(yy).setVisualizer($NAME)
	| PORTRAIT 			-> getGraphRoot(yy).setDirection("portrait")
	| COMMENT 			-> "/*"+$COMMENT.substring(2)+"*/\n"
	| NODE_COLOR colorOrVariable		-> getCurrentContainer(yy).setDefault('nodecolor',$2=="default"?undefined:$2)
	| NODETEXT_COLOR colorOrVariable	-> getCurrentContainer(yy).setDefault('nodetextcolor',$2=="default"?undefined:$2)
	| LINK_COLOR colorOrVariable		-> getCurrentContainer(yy).setDefault('linkcolor',$2=="default"?undefined:$2)
	| LINKTEXT_COLOR colorOrVariable	-> getCurrentContainer(yy).setDefault('linktextcolor',$2=="default"?undefined:$2)
	| GROUP_COLOR colorOrVariable	-> getCurrentContainer(yy).setDefault('groupcolor',$2=="default"?undefined:$2)
	/* conditionals*/
	| IF 	 ->	setAttr(enterContainer(yy,getGroup(yy).setLabel($IF)),'conditional','if')
	| ELSEIF {
		exitContainer(yy);
		$$=setAttr(enterContainer(yy,getGroup(yy).setLabel($ELSEIF)),'conditional','elseif')
		}
	| ELSE 	 {
		exitContainer(yy);
		$$=setAttr(enterContainer(yy,getGroup(yy).setLabel($ELSE)),'conditional','else')
		}
	| ENDIF	 { 
		exitContainer(yy);
		setAttr(enterContainer(yy,getGroup(yy).setLabel($ENDIF)),'conditional','endif');
		$$=exitContainer(yy)
	} 
	/* actual nodes*/
	| GROUP groupTarget {}
	| GROUP_END 	-> exitContainer(yy)
	| START NAME 	-> getGraphRoot(yy).setStart($NAME)
	| nodesAndEvents {
	}
	;
%% 
