/* parser generated by jison 0.4.15 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[10,14],$V1=[2,38],$V2=[1,3],$V3=[1,25],$V4=[1,27],$V5=[1,4],$V6=[1,5],$V7=[1,6],$V8=[1,7],$V9=[1,8],$Va=[1,9],$Vb=[1,10],$Vc=[1,11],$Vd=[1,12],$Ve=[1,13],$Vf=[1,14],$Vg=[1,15],$Vh=[1,16],$Vi=[1,17],$Vj=[1,18],$Vk=[1,19],$Vl=[1,20],$Vm=[1,21],$Vn=[1,22],$Vo=[1,29],$Vp=[1,5,8,10,14,19,22,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,52,53,54],$Vq=[1,40],$Vr=[1,41],$Vs=[7,8,30,51],$Vt=[1,5,8,10,14,19,22,25,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,52,53,54,55],$Vu=[1,52],$Vv=[1,5,8,10,14,19,20,22,25,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,52,53,54,55],$Vw=[1,5,8,10,14,19,20,22,25,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,51,52,53,54,55,56,57],$Vx=[30,51],$Vy=[10,14,54],$Vz=[7,8,10,14,19,22,54,57],$VA=[10,14,19,22,54,57],$VB=[10,14,19,22,54];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"S":3,"graphContent":4,"EOF":5,"colorOrVariable":6,"COLOR":7,"VARIABLE":8,"shapeOrVariable":9,"SHAPES":10,"readNodeAttrs":11,"readNodeAttrs_option0":12,"readNodeAttrs_option1":13,"NAME":14,"readNodeAttrs_option2":15,"readNodeAttrs_option3":16,"readNodeAttrs_option4":17,"nodeGroupListOrAttrs":18,"OPAREN":19,"LISTSEP":20,"nodeGroupListOrAttrs_option0":21,"CPAREN":22,"readEvents":23,"readEvents_option0":24,"EVENT":25,"readEvents_option1":26,"readEvents_option2":27,"readEvents_option3":28,"readEvents_option4":29,"LABEL":30,"SHAPE":31,"EQUAL":32,"LANDSCAPE":33,"GENERATOR":34,"VISUALIZER":35,"PORTRAIT":36,"COMMENT":37,"NODE_COLOR":38,"NODETEXT_COLOR":39,"LINK_COLOR":40,"LINKTEXT_COLOR":41,"GROUP_COLOR":42,"IF":43,"ELSEIF":44,"ELSE":45,"ENDIF":46,"GROUP":47,"graphContent_option0":48,"graphContent_option1":49,"graphContent_option2":50,"GROUP_DECLARATION_END":51,"GROUP_END":52,"START":53,"STYLES":54,"COMPASS":55,"IMAGE":56,"INLINE_STRING":57,"GROUPNAME":58,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",7:"COLOR",8:"VARIABLE",10:"SHAPES",14:"NAME",19:"OPAREN",20:"LISTSEP",22:"CPAREN",25:"EVENT",30:"LABEL",31:"SHAPE",32:"EQUAL",33:"LANDSCAPE",34:"GENERATOR",35:"VISUALIZER",36:"PORTRAIT",37:"COMMENT",38:"NODE_COLOR",39:"NODETEXT_COLOR",40:"LINK_COLOR",41:"LINKTEXT_COLOR",42:"GROUP_COLOR",43:"IF",44:"ELSEIF",45:"ELSE",46:"ENDIF",47:"GROUP",51:"GROUP_DECLARATION_END",52:"GROUP_END",53:"START",54:"STYLES",55:"COMPASS",56:"IMAGE",57:"INLINE_STRING",58:"GROUPNAME"},
productions_: [0,[3,1],[3,2],[3,2],[6,1],[6,1],[9,1],[9,1],[11,6],[18,1],[18,4],[18,1],[18,1],[23,8],[23,2],[23,1],[4,1],[4,2],[4,2],[4,2],[4,1],[4,2],[4,2],[4,1],[4,1],[4,2],[4,2],[4,2],[4,2],[4,2],[4,1],[4,1],[4,1],[4,1],[4,5],[4,1],[4,2],[4,1],[12,0],[12,1],[13,0],[13,1],[15,0],[15,1],[16,0],[16,1],[17,0],[17,1],[21,0],[21,1],[24,0],[24,1],[26,0],[26,1],[27,0],[27,1],[28,0],[28,1],[29,0],[29,1],[48,0],[48,1],[49,0],[49,1],[50,0],[50,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1: case 4: case 7: case 11:
this.$ = $$[$0];
break;
case 2:
this.$ = $$[$0-1] + $$[$0];
break;
case 3:

			/* 	- caller can ALWAYS specify the generator
				- caller can ALWAYS specify the visualizer
				- only graphviz has multiple visualizer (currently it 
				  only draws digraphs, but those can be visualized with dot, neato.circo etc)
				- generator/visualizer(since different grammars)
					- mscgen=mscgen
					- seqdiag=seqdiag
					- blockdiag=blockdiag
					- nwdiag=nwdiag
					- ast=ast
					- plantuml_sequence=plantuml_sequence

					PlantUML MIGHT BE plantuml/[sequence|activty etc.]
				- If visualizer given, RECORD it, do not use...
				- Caller can then (willingly) check for LANGUAGE given visualizer(or generator) and
				  override those or obey to those. Those would be suggested tools to use...
			*/
			var generator=getGraphRoot(yy).getGenerator();
			if (yy.OUTPUT)
			  generator=yy.OUTPUT;
			if (!yy.OUTPUT)
			  yy.OUTPUT=generator;
			if (!yy.VISUALIZER)
			  yy.VISUALIZER=getGraphRoot(yy).getVisualizer();
			if (!yy.VISUALIZER){
			  if( generator=="digraph")
			    yy.VISUALIZER="dot";
		  	  else
			    yy.VISUALIZER=generator;
			}
			if ("ast" == generator){
				ast(yy);
			}else if ("dexgraph" == generator){
				dexgraph(yy);
			}else if ("actdiag" == generator){
				actdiag(yy);
			}else if ("blockdiag" == generator){
				blockdiag(yy);
			}else if ("nwdiag" == generator){
				nwdiag(yy);
			}else if ("seqdiag" == generator){
				seqdiag(yy);
			}else if ("mscgen" == generator){
				mscgen(yy);
			}else if ("plantuml_sequence" == generator){
				plantuml_sequence(yy);
			//could be tree/dendrogram rather!
			}else if ("dendrogram" == generator){
				dendrogram(yy);
			}else if ("sankey" == generator){
				sankey(yy);
			}else{
				//rankdir available ONLY IN dot
				digraph(yy);
			}
			return $$[$0-1];
		
break;
case 5:
this.$ = processVariable(yy,$$[$0]) /*one can use named $$[$0] or positional $$[$0] args, like former, but latter seem more ...readable*/;
break;
case 6:

			this.$=processVariable(yy,$$[$0]).trim().toLowerCase();
			if (["actor","beginpoint","box","circle","cloud","condition","database","default","diamond","dots","doublecircle",
				 "ellipse","endpoint","input","loopin","loopout","mail","minidiamond","minisquare","note","record","roundedbox",
				 "square","terminator","loop","loopend","loopstart","rect","rectangle"].indexOf(this.$)==-1){
				throw new Error("Must use declared shape");
			}
	
break;
case 8:
this.$ = getNode(yy,$$[$0-3],$$[$0-5]).setColor($$[$0-1]);if (this.$ instanceof Node) setAttr(this.$.setShape($$[$0-4]).setImage($$[$0]),'compass',$$[$0-2]);
break;
case 9:
this.$ = enterSubGraph(yy);
break;
case 10:
this.$ = getList(yy,$$[$0-3],$$[$0],$$[$0-1]);
break;
case 12:
this.$ = exitSubGraph(yy);
break;
case 13:
this.$ = getLink(yy,$$[$0-5],$$[$0-7],$$[$0-1],$$[$0-2],$$[$0]?$$[$0].substring(1):$$[$0],$$[$0-3],$$[$0-6],$$[$0-4]).right;
break;
case 14:
this.$ = this.$.setLabel($$[$0].substring(1));
break;
case 16:
this.$ = processVariable(yy,$$[$0]);
break;
case 17:

			debug("SHAPE getShapeOrVariablleee ");
			if ($$[$0]=="default") $$[$0]=undefined;
			this.$=getGraphRoot(yy).setCurrentShape($$[$0]);
		
break;
case 18:

			getCurrentContainer(yy).setEqual($$[$0] instanceof Node?new Array($$[$0]):$$[$0]);
		
break;
case 19:
throw new Error("Expecting one of the shapes, got ("+$$[$0]+")");
break;
case 20:
this.$ = getGraphRoot(yy).setDirection("landscape");
break;
case 21:
this.$ = getGraphRoot(yy).setGenerator($$[$0]);
break;
case 22:
this.$ = getGraphRoot(yy).setVisualizer($$[$0]);
break;
case 23:
this.$ = getGraphRoot(yy).setDirection("portrait");
break;
case 24:
this.$ = "/*"+$$[$0].substring(2)+"*/\n";
break;
case 25:
this.$ = getCurrentContainer(yy).setDefault('nodecolor'    ,$$[$0]=="default"?undefined:$$[$0]);
break;
case 26:
this.$ = getCurrentContainer(yy).setDefault('nodetextcolor',$$[$0]=="default"?undefined:$$[$0]);
break;
case 27:
this.$ = getCurrentContainer(yy).setDefault('linkcolor'    ,$$[$0]=="default"?undefined:$$[$0]);
break;
case 28:
this.$ = getCurrentContainer(yy).setDefault('linktextcolor',$$[$0]=="default"?undefined:$$[$0]);
break;
case 29:
this.$ = getCurrentContainer(yy).setDefault('groupcolor'   ,$$[$0]=="default"?undefined:$$[$0]);
break;
case 30:
this.$ =	setAttr(setAttr(enterContainer(yy,getGroup(yy).setLabel($$[$0].replace(/\s+then\s*$/,"").replace(/^\s*if\s*/,""))),'conditional','if'),'entrylink',yy.lastSeenNode);
break;
case 31:

		exitContainer(yy);
		this.$=setAttr(enterContainer(yy,getGroup(yy).setLabel($$[$0].replace(/\s+then\s*$/,"").replace(/^\s*elseif\s*/,""))),'conditional','elseif')
		
break;
case 32:

		exitContainer(yy);
		this.$=setAttr(enterContainer(yy,getGroup(yy).setLabel($$[$0])),'conditional','else')
		
break;
case 33:
 
		exitContainer(yy);
		//TODO: is ENDIF container necessary?YES, it could be invisible node! Could link to that instead of endif kludge in digraph
		yy.collectNextNode=setAttr(enterContainer(yy,getGroup(yy).setLabel($$[$0])),'conditional','endif')
		debug("XXXXXXXXXXXXXXXXXXXXX collectNextNode"+yy.collectNextNode);
		this.$=exitContainer(yy)
	
break;
case 34:
this.$ = enterContainer(yy,getGroup(yy).setName($$[$0-3]).setColor($$[$0-2]).setLabel($$[$0-1]==undefined?undefined:$$[$0-1].substring(1)));
break;
case 35:
this.$ = exitContainer(yy);
break;
case 36:
this.$ = getGraphRoot(yy).setStart($$[$0]);
break;
case 37:

	
break;
}
},
table: [o($V0,$V1,{3:1,4:2,23:23,18:24,11:26,12:28,8:$V2,19:$V3,22:$V4,31:$V5,32:$V6,33:$V7,34:$V8,35:$V9,36:$Va,37:$Vb,38:$Vc,39:$Vd,40:$Ve,41:$Vf,42:$Vg,43:$Vh,44:$Vi,45:$Vj,46:$Vk,47:$Vl,52:$Vm,53:$Vn,54:$Vo}),o($V0,$V1,{23:23,18:24,11:26,12:28,4:30,1:[3],5:[1,31],8:$V2,19:$V3,22:$V4,31:$V5,32:$V6,33:$V7,34:$V8,35:$V9,36:$Va,37:$Vb,38:$Vc,39:$Vd,40:$Ve,41:$Vf,42:$Vg,43:$Vh,44:$Vi,45:$Vj,46:$Vk,47:$Vl,52:$Vm,53:$Vn,54:$Vo}),o($Vp,[2,1]),o($Vp,[2,16]),{8:[1,34],9:32,10:[1,35],14:[1,33]},o($V0,$V1,{11:26,12:28,18:36,19:$V3,22:$V4,54:$Vo}),o($Vp,[2,20]),{14:[1,37]},{14:[1,38]},o($Vp,[2,23]),o($Vp,[2,24]),{6:39,7:$Vq,8:$Vr},{6:42,7:$Vq,8:$Vr},{6:43,7:$Vq,8:$Vr},{6:44,7:$Vq,8:$Vr},{6:45,7:$Vq,8:$Vr},o($Vp,[2,30]),o($Vp,[2,31]),o($Vp,[2,32]),o($Vp,[2,33]),o($Vs,[2,60],{48:46,58:[1,47]}),o($Vp,[2,35]),{14:[1,48]},o($Vp,[2,37],{24:49,25:[2,50],30:[1,50],55:[1,51]}),o($Vt,[2,15],{20:$Vu}),o($Vv,[2,9]),o($Vv,[2,11]),o($Vv,[2,12]),{10:[1,54],13:53,14:[2,40]},o($V0,[2,39]),o($Vp,[2,2]),o($Vp,[2,3]),o($Vp,[2,17]),o($Vp,[2,19]),o($Vp,[2,6]),o($Vp,[2,7]),o($Vp,[2,18],{20:$Vu}),o($Vp,[2,21]),o($Vp,[2,22]),o($Vp,[2,25]),o($Vw,[2,4]),o($Vw,[2,5]),o($Vp,[2,26]),o($Vp,[2,27]),o($Vp,[2,28]),o($Vp,[2,29]),o($Vx,[2,62],{49:55,6:56,7:$Vq,8:$Vr}),o($Vs,[2,61]),o($Vp,[2,36]),{25:[1,57]},o($Vt,[2,14]),{25:[2,51]},o($Vy,[2,48],{21:58,57:[1,59]}),{14:[1,60]},{14:[2,41]},{30:[1,62],50:61,51:[2,64]},o($Vx,[2,63]),o($Vz,[2,52],{26:63,55:[1,64]}),o($V0,$V1,{12:28,11:65,54:$Vo}),o($Vy,[2,49]),o([1,5,7,8,10,14,19,20,22,25,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,52,53,54,56],[2,42],{15:66,55:[1,67]}),{51:[1,68]},{51:[2,65]},o($VA,[2,54],{27:69,6:70,7:$Vq,8:$Vr}),o($Vz,[2,53]),o($Vv,[2,10]),o([1,5,10,14,19,20,22,25,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,52,53,54,55,56],[2,44],{16:71,6:72,7:$Vq,8:$Vr}),o([1,5,7,8,10,14,19,20,22,25,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,52,53,54,55,56],[2,43]),o($Vp,[2,34]),o($VB,[2,56],{28:73,57:[1,74]}),o($VA,[2,55]),o($Vv,[2,46],{17:75,56:[1,76]}),o([1,5,8,10,14,19,20,22,25,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,52,53,54,55,56],[2,45]),o($V0,$V1,{11:26,12:28,18:77,19:$V3,22:$V4,54:$Vo}),o($VB,[2,57]),o($Vv,[2,8]),o($Vv,[2,47]),o([1,5,8,10,14,19,22,25,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,52,53,54,55],[2,58],{29:78,20:$Vu,30:[1,79]}),o($Vt,[2,13]),o($Vt,[2,59])],
defaultActions: {51:[2,51],54:[2,41],62:[2,65]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        throw new Error(str);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        function lex() {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};
 
/**
 * Create a new generic graph object
 * @param [label] Optional label
 * @constructor
 */
function GraphObject(label) {
    this.setName = function (value) {
        if (value === undefined) return this;
        return setAttr(this, 'name', value);
    };
    this.getName = function () {
        return getAttr(this, 'name');
    };
    this.setColor = function (value) {
        if (value === undefined) return this;
        return setAttr(this, 'color', value);
    };
    this.getColor = function () {
        return getAttr(this, 'color');
    };
    this.setTextColor = function (value) {
        if (value === undefined) return this;
        return setAttr(this, 'textcolor', value);
    };
    //noinspection JSUnusedGlobalSymbols
    this.getTextColor = function () {
        return getAttr(this, 'textcolor');
    };
    this.setUrl = function (value) {
        if (value === undefined) return this;
        return setAttr(this, 'url', value);
    };
    //noinspection JSUnusedGlobalSymbols
    this.getUrl = function () {
        return getAttr(this, 'url');
    };
    this.label = label;
    this.setLabel = function (value) {
        if (!value) return this;
        value = value.trim().replace(/"/gi, "");
        //debug("graphobject:TEST value(" + value + ") for color");
        //Take out COLOR if preset
        var m = value.match(/^(#[A-Fa-f0-9]{6,6})(.*)$/);
        // debug(m);
        if (m !== null && m.length == 3) {
            this.setTextColor(m[1]);
            value = m[2].trim();
        }
        m = value.match(/\[([^\]]+)\](.*)$/);
        if (m !== null && m.length >= 3) {
            this.setUrl(m[1]);
            value = m[2].trim();
        }
        return setAttr(this, 'label', value);
    };
    this.getLabel = function () {
        return getAttr(this, 'label');
    };
    this.toString = function () {
        return "GraphObject";
    };
}
GraphRoot.prototype = new GraphObject();
GraphRoot.prototype.constructor = GraphRoot;

/**
 * Create a new graph root
 * @constructor
 */
function GraphRoot() {
    this.OBJECTS = [];
    this.ROOTNODES = [];
    this.setGenerator = function (value) {
        if (value) value = value.toLowerCase();
        return setAttr(this, 'generator', value);
    };
    this.getGenerator = function () {
        return getAttr(this, 'generator');
    };
    this.setVisualizer = function (value) {
        if (value) value = value.toLowerCase();
        return setAttr(this, 'visualizer', value);
    };
    this.getVisualizer = function () {
        return getAttr(this, 'visualizer');
    };
    this.setCurrentShape = function (value) {
        if (value) value = value.toLowerCase();
        return setAttr(this, 'shape', value);
    };
    this.getCurrentShape = function () {
        return getAttr(this, 'shape');
    };
    this.setDirection = function (value) {
        return setAttr(this, 'direction', value);
    };
    this.getDirection = function () {
        return getAttr(this, 'direction');
    };
    this.setStart = function (value) {
        return setAttr(this, 'start', value);
    };
    this.getStart = function () {
        return getAttr(this, 'start');
    };
    // Save EQUAL node ranking
    this.setEqual = function (value) {
        return setAttr(this, 'equal', value);
    };
    this.getEqual = function () {
        return getAttr(this, 'equal');
    };
    /**
     * Set default nodecolor, groupcolor, linkcolor Always ask from the
     * currentContainer first
     */
    this.setDefault = function (key, value) {
        //debug("graphroot:Set ROOT " + key + " to " + value);
        return setAttr(this, key, value);
    };
    this.getDefault = function (key) {
        // debug("graphroot:Get ROOT "+key);
        return getAttr(this, key);
    };
    this.toString = function () {
        return "GraphRoot";
    };
}
Group.prototype = new GraphObject();
Group.prototype.constructor = Group;

/**
 * Create a new container group
 * @param name Name of the container
 * @constructor
 */
function Group(name) {
    this.name = name;
    this.OBJECTS = [];
    this.ROOTNODES = [];
    // Save EQUAL node ranking
    this.setEqual = function (value) {
        return setAttr(this, 'equal', value);
    };
    this.getEqual = function () {
        return getAttr(this, 'equal');
    };
    // temporary for RHS list array!!
    this.setLinkLabel = function (value) {
        return setAttr(this, 'linklabel', value);
    };
    this.getLinkLabel = function () {
        return getAttr(this, 'linklabel');
    };
    /**
     * Set default nodecolor, groupcolor, linkcolor Always ask from the
     * currentContainer first
     */
    this.setDefault = function (key, value) {
        debug("group:Set group " + key + " to " + value);
        return setAttr(this, key, value);
    };
    this.getDefault = function (key) {
        debug("group:Get group " + key);
        return getAttr(this, key);
    };
    this.toString = function () {
        return "group:Group(" + this.name + ")";
    };
}
Link.prototype = new GraphObject();
Link.prototype.constructor = Link;

/**
 * Create a new link between objects (nodes,groups,lists)
 *
 * @param linkType Type of the link(grammar!)
 * @param l Left hand side of the link
 * @param r Right hand side of the link
 * @constructor
 */
function Link(linkType, l, r) {
    this.linkType = linkType.trim();
    this.left = l;
    this.right = r;
    this.toString = function () {
	var fmt=""; 
	var tmp = getAttrFmt(this, 'lcompass','');
	if (tmp !== undefined && tmp != '')
	    fmt += ",lcompass: " + tmp;
	tmp = getAttrFmt(this, 'rcompass','');
	if (tmp !== undefined && tmp != '')
	    fmt += ",rcompass: " + tmp;
	tmp = getAttrFmt(this, 'linkcolor','');
	if (tmp !== undefined && tmp != '')
	    fmt += ",color: " + tmp;
	tmp = getAttrFmt(this, 'linktextcolor','');
	if (tmp !== undefined && tmp != '')
	    fmt += ",textcolor: " + tmp;
        return "Link(type:" + this.linkType + " as L:" +
            this.left.toString() + ", R:" +
            this.right.toString() + ",label=" +
            this.getLabel() + fmt + ")";
    };
}
//noinspection JSUnusedGlobalSymbols,JSUnusedGlobalSymbols
/**
 *
 * Called from grammar to inject a new (COLOR) variable
 * Only colors supported currently, though there's really no limitation
 *
 * If this is assignment, rewrite the variable, else assign new
 * Always return the current value
 *
 * @param yy Lexer yy
 * @param variable ${XXX:yyy} assignment or ${XXX} query
 */
function processVariable(yy, variable) {
    // ASSIGN VARIABLE
    // $(NAME:CONTENT...)
    // or
    // refer variable
    // $(NAME)
    var vari = variable.slice(2, -1);
    if (vari.indexOf(":") !== -1) {
        // Assignment
        var tmp = vari.split(":");
        debug("GOT assignment " + tmp[0] + "=" + tmp[1]);
        getVariables(yy)[tmp[0]] = tmp[1];
        return tmp[1];
    } else {
        // referral
        if (!getVariables(yy)[vari]) {
            throw new Error("Variable " + vari + " not defined");
        }
        return getVariables(yy)[vari];
    }
}

/**
 * Return all the variables from the collection (hard coded to yy)
 */
function getVariables(yy) {
    if (!yy.VARIABLES) {
        yy.VARIABLES = {}
    }
    return yy.VARIABLES;
}

/**
 * Get current singleton graphroot or create  new one
 */
function getGraphRoot(yy) {
    // debug(" getGraphRoot "+yy);
    if (!yy.GRAPHROOT) {
        //debug("no graphroot,init - in getGraphRoot",true);
        if (yy.result === undefined) {
            yy.result = function (str) {
                console.log(str);
            }
        }
        debug("...Initialize emptyroot " + yy);
        yy.CURRENTCONTAINER = [];
        yy.LINKS = [];
        yy.CONTAINER_EXIT = 1;
        yy.GRAPHROOT = new GraphRoot();
        // yy.GRAPHROOT.setCurrentContainer(yy.GRAPHROOT);
        enterContainer(yy, yy.GRAPHROOT);
        //debug(false);
    }
    return yy.GRAPHROOT;
}

/**
 * Create an array, push LHS,RHS nodes there and return the array as long as
 * processing the list nodes added to array..
 *
 * @param yy Lexer yy
 * @param LHS left hand side of the list
 * @param RHS right hand side of the list
 * @param rhsLinkLabel optional RHS label
 */
function getList(yy, LHS, RHS, rhsLinkLabel) {
    if (LHS instanceof Node) {
        debug("getList(node:" + LHS + ",rhs:[" + RHS + "])",true);
        var x = [];
        x.push(LHS);
	//TODO assuming RHS is Node
        x.push(getNode(yy, RHS).setLinkLabel(rhsLinkLabel));
        debug("return node:"+x,false);
        return x;
    }
    if (LHS instanceof Group) {
        debug("getList(group:[" + LHS + "],rhs:" + RHS + ")",true);
        var x = [];
        x.push(LHS);
	//TODO assuming RHS is Group
        x.push(getGroup(yy, RHS).setLinkLabel(rhsLinkLabel));
        debug("return group:"+x,false);
        return x;
    }
    debug("getList(lhs:[" + LHS + "],rhs:" + RHS,true);
    // LHS not a node..
    LHS.push(getNode(yy, RHS).setLinkLabel(rhsLinkLabel));
    debug("return ["+LHS+"]",false);
    return LHS;
}

/**
 * See readNodeOrGroup in grammar
 *
 * Return matching Node,Array,Group
 *
 * If no match, create a new node
 *
 * STYLE will always be updated on last occurance (ie. dashed a1
 * dotted a1>b1 - only for nodes!
 *
 * node a1 will be dotted instead of being dashed
 *
 * @param yy Lexer yy
 * @param name Reference, Node/Array/Group
 * @param [style] OPTIONAL if style given, update (only if name refers to node)
 */
function getNode(yy, name, style) {
    debug("getNode (name:"+name+",style:"+style+")",true);
    function cc(yy, name, style) {
        if (name instanceof Node) {
            if (style) name.setStyle(style);
            return name;
        }
        if (name instanceof Array) {
            return name;
        }

        var search = function s(container, name) {
            if (container.getName() == name) return container;
            for (var i in container.OBJECTS) {
                if (!container.OBJECTS.hasOwnProperty(i))continue;
                var o = container.OBJECTS[i];
                if (o instanceof Node && o.getName() == name) {
                    if (style) o.setStyle(style);
                    return o;
                }
                if (o instanceof Group) {
                    var found = s(o, name);
                    if (found != undefined) return found;
                }
            }
            return undefined;
        }(getGraphRoot(yy), name);
        if (search !== undefined) {
            return search;
        }
        debug("Create new node name="+name,true);
        var n = new Node(name, getGraphRoot(yy).getCurrentShape());
        if (style) n.setStyle(style);
	n.nolinks=true;

        getDefaultAttribute(yy, 'nodecolor', function (color) {
            n.setColor(color);
        });
        getDefaultAttribute(yy, 'nodetextcolor', function (color) {
            n.setTextColor(color);
        });
        debug(false);
        return pushObject(yy, n);
    }

    var node = cc(yy, name, style);
    debug("  in getNode gotNode " + node);
    yy.lastSeenNode = node;
    if (yy.collectNextNode) {
        debug("Collect next node");
        setAttr(yy.collectNextNode, 'exitlink', name);
        yy.collectNextNode = undefined;
    }
    debug(false);
    return node;
}

/**
 * Get default attribute nodecolor,linkcolor,groupcolor and bubble upwards if
 * otherwise 'unobtainable'
 *
 * @param yy lexer
 * @param attrname Name of the default attribute. If not found, returns undefined
 * @param [x] Pass the attribute to the this function as only argument - if attribute WAS actually defined!
 */
function getDefaultAttribute(yy, attrname, x) {
    // no need for the value, but runs init if missing
    getGraphRoot(yy);
    // debug("getDefaultAttribute "+attrname);
    var a;
    for (var i in yy.CURRENTCONTAINER) {
        if (!yy.CURRENTCONTAINER.hasOwnProperty(i))continue;
        var ctr = yy.CURRENTCONTAINER[i];
        a = ctr.getDefault(attrname);
        // debug(" traverse getDefaultAttribute "+attrname+" from "+ctr+" as
        // "+a);
        if (a !== undefined) {
            // debug("getDefaultAttribute "+attrname+" from "+ctr+"=("+a+")");
            if (x !== undefined)
                x(a);
            return a;
        }
    }
    a = getGraphRoot(yy).getDefault(attrname);
    if (a !== undefined) {
        debug("getDefaultAttribute got from graphroot");
        if (x !== undefined)
            x(a);
        return a;
    }
    // debug("getDefaultAttribute FAILED");
    return undefined;
}

/**
 * TODO: DUAL DECLARATION
 *
 * Get current container
 * @para, yy Lexer
 */
function getCurrentContainer(yy) {
    // no need for value, but runs init if missing
    getGraphRoot(yy);
    return yy.CURRENTCONTAINER[yy.CURRENTCONTAINER.length - 1];
}

/**
 * Enter into a new container, set it as current container
 * @param yy lexer
 * @param container Set this container as current container
 */
function enterContainer(yy, container) {
    yy.CURRENTCONTAINER.push(container);
    // yy.GRAPHROOT.setCurrentContainer(yy.GRAPHROOT);
    return container;
}

//noinspection JSUnusedGlobalSymbols
/**
 * Exit the current container
 * Return the previous one
 * Previous one also set as current container
 * @param yy lexer
 */
function exitContainer(yy) {
    if (yy.CURRENTCONTAINER.length <= 1)
        throw new Error("INTERNAL ERROR:Trying to exit ROOT container");
    return setAttr(yy.CURRENTCONTAINER.pop(), 'exitnode', yy.CONTAINER_EXIT++);
}

/**
 * Enter to a new parented sub graph
 * like in a>(b>c,d,e)>h
 *
 * Edit grammar so it links a>b and c,d,e to h
 * Ie exit node(s) and enrance node(s) linked properly
 */
function enterSubGraph(yy) {
    return enterContainer(yy, getSubGraph(yy));
}

function hasOutwardLink(yy,node) {
    for (var i in yy.LINKS) {
        if (!yy.LINKS.hasOwnProperty(i))continue;
        var r = yy.LINKS[i];
        if (r.left.name === node.name){
            return true;
        }
    }
    return false;
}

/**
 * return true if node has inward link OUTSIDE container it is in
 */
function hasInwardLink(yy, node, nodesContainer) {
    for (var i in yy.LINKS) {
        if (!yy.LINKS.hasOwnProperty(i))continue;
        var r = yy.LINKS[i];
	if (nodesContainer !== undefined &&
	    r.container.name === nodesContainer.name) {
	    continue;
	}
	if (r.right.name === node.name) {
            return true;
        }
    }
    return false;
}

function exitSubGraph(yy) {
    //Now should edit the ENTRANCE LINK to point to a>b, a>d, a>e
    var currentSubGraph = getCurrentContainer(yy);
    debug('Exit subgraph '+currentSubGraph);
    var l = null;
    var i = 0;

    //fix entrance
    for (i in yy.LINKS) {
        if (!yy.LINKS.hasOwnProperty(i))continue;
        l = yy.LINKS[i];
        if (l.right.name == currentSubGraph.name && l.left.name == currentSubGraph.entrance.name) {
            //remove this link!
            yy.LINKS.splice(i,1);
            //and then relink it to containers nodes that have no LEFT links
            break;
        }
        l=null;
    }

    if (l!==null){
	//and then relink it to containers nodes that have no LEFT links
	//traverse
	for(var o in currentSubGraph.ROOTNODES) {
            if (!currentSubGraph.ROOTNODES.hasOwnProperty(o))continue;
            var g = currentSubGraph.ROOTNODES[o];
	    currentSubGraph.entrance.nolinks=undefined;
	    g.nolinks=undefined;
	    var newLink = getLink(yy, l.linkType, currentSubGraph.entrance, g, l.label,
				  undefined, undefined, undefined, undefined, true);
	    setAttr(newLink, 'container', currentSubGraph);
	    yy.LINKS.splice(i++,0, newLink);
	}
    }

    //fix exits
    //{"link":{"linkType":">","left":1,"right":"z","label":"from e and h"}}
    var exits = [];
    for(var o in currentSubGraph.OBJECTS) {
        if (!currentSubGraph.OBJECTS.hasOwnProperty(o))continue;
        var g = currentSubGraph.OBJECTS[o];
        if (!hasOutwardLink(yy,g)) {
            exits.push(g);
        }
    }

    debug('exits '+exits);
    currentSubGraph.setExit(g);
    return exitContainer(yy);
}

//noinspection JSUnusedGlobalSymbols
/**
 * Create a NEW GROUP if one (ref) does not exist yet getGroup(yy) => create a
 * new anonymous group getGroup(yy,GroupRef) => create a new group if GroupRef
 * is not a Group or return GroupRef if it is...1
 * @param yy lexer
 * @param ref Type of reference, if group, return it
 * @return ref if ref instance of group, else the newly created group
 */
function getGroup(yy, ref) {
    if (ref instanceof Group) return ref;
    debug("getGroup() NEW GROUP:" + yy + "/" + ref,true);
    if (yy.GROUPIDS === undefined) yy.GROUPIDS = 1;
    var newGroup = new Group(yy.GROUPIDS++);
    debug("push group " + newGroup + " to " + yy);
    pushObject(yy, newGroup);

    getDefaultAttribute(yy, 'groupcolor', function (color) {
        newGroup.setColor(color);
    });
    debug(false);
    return newGroup;
}

/**
 * Create a new sub graph
 */
function getSubGraph(yy, ref) {
    if (ref instanceof SubGraph) return ref;
    //debug("getSubGraph() NEW SubGraph:" + yy + "/" + ref,true);
    if (yy.SUBGRAPHS === undefined) yy.SUBGRAPHS = 1;
    var newSubGraph = new SubGraph(yy.SUBGRAPHS++);
    //debug("push SubGraph " + newSubGraph + " to " + yy);
    pushObject(yy, newSubGraph);
    //debug(false);
    return newSubGraph;
}
// Get a link such that l links to r, return the added LINK or LINKS

//noinspection JSUnusedGlobalSymbols
/**
 * linkType >,<,.>,<.,->,<-,<> l = left side, Node(xxx) or Group(yyy), or
 * Array(smthg) r = right side, Node(xxx) or Group(yyy), or Array(smthg) label =
 * if defined, LABEL for the link color = if defined, COLOR for the link
 *
 * if there is a list a>b,c,x,d;X then X is gonna e link label for EVERYONE
 * but for a>"1"b,"2"c link label is gonna be individual! 
 * @param yy lexer
 * @param linkType Type of the link(grammar)
 * @param l Left hand side (must be Array,Node,Group)
 * @param r Right hand side (must be Array,Node,Group)
 * @param [inlineLinkLabel] Optional label for the link
 * @param [commonLinkLabel] Optional label for the link
 * @param [linkColor] Optional color for the link
 * @param [lcompass] Left hand side compass value
 * @param [rcompass] Reft hand side compass value
 * @return the link that got added
 */
function getLink(yy, linkType, l, r, inlineLinkLabel, commonLinkLabel, linkColor, lcompass, rcompass, dontadd) {
    var lastLink;
    var i;
    var current_container = getCurrentContainer(yy);

    debug(true);
    if (r instanceof SubGraph && r.getEntrance()==undefined) {
        r.setEntrance(l);
    }
    if (r.nolinks === true && current_container!==undefined) {
	debug('REMOVE '+r+' from root nodes of the container '+current_container);
	var idx=current_container.ROOTNODES.indexOf(r);
	if (idx>=0) {
	    current_container.ROOTNODES.splice(idx,1);
        }
    }
    l.nolinks=undefined;
    r.nolinks=undefined;

    if (current_container  instanceof SubGraph && 
	current_container.getEntrance()==undefined && 
	l instanceof Node && 
	!(r instanceof SubGraph)) {
	current_container.setEntrance(l);
    }

    if (l instanceof Array) {
        debug("getLink LHS array, type:"+linkType+" l:["+l+"] r:"+r+" inlineLinkLabel:"+inlineLinkLabel+" commonLinkLabel: "+commonLinkLabel+" linkColor:"+linkColor+" lcompass:"+lcompass+" rcompass:"+rcompass);
        for (i = 0; i < l.length; i++) {
            debug("    1Get link " + l[i]);
            lastLink = getLink(yy, linkType, l[i], r, inlineLinkLabel, commonLinkLabel, linkColor, lcompass, rcompass);
        }
        debug(false);
        return lastLink;
    }
    if (r instanceof Array) {
        debug("getLink RHS array, type:"+linkType+" l:"+l+" r:["+r+"] inlineLinkLabel:"+inlineLinkLabel+" commonLinkLabel: "+commonLinkLabel+" linkColor:"+linkColor+" lcompass:"+lcompass+" rcompass:"+rcompass);
        for (i = 0; i < r.length; i++) {
            debug("    2Get link " + r[i]);
            lastLink = getLink(yy, linkType, l, r[i], inlineLinkLabel, commonLinkLabel, linkColor, lcompass, rcompass);
        }
        debug(false);
        return lastLink;
    }
    var fmt = "";
    if (inlineLinkLabel !== undefined)
      fmt += "inlineLinkLabel: "+inlineLinkLabel;
    if (commonLinkLabel !== undefined)
      fmt += "commonLinkLabel: "+commonLinkLabel;
    if (linkColor !== undefined)
      fmt += "linkColor: "+linkColor;
    if (lcompass !== undefined)
      fmt += "lcompass: "+lcompass;
    if (rcompass !== undefined)
      fmt += "rcompass: "+rcompass;
    debug("getLink type:"+linkType+" l:"+l+" r:"+r+fmt);
    if (!(l instanceof Node) && !(l instanceof Group)& !(l instanceof SubGraph)) {
        throw new Error("LHS not a Node,Group nor a SubGraph(LHS=" + l + ") RHS=(" + r + ")");
    }
    if (!(r instanceof Node) && !(r instanceof Group)&& !(r instanceof SubGraph)) {
        throw new Error("RHS not a Node,Group nor a SubGraph(LHS=" + l + ") RHS=(" + r + ")");
    }
    var lnk = new Link(linkType, l, r);

    if (lcompass) setAttr(lnk, 'lcompass', lcompass);
    else if (getAttr(l, 'compass')) setAttr(lnk, 'lcompass', getAttr(l, 'compass'));

    if (rcompass) setAttr(lnk, 'rcompass', rcompass);
    else if (getAttr(r, 'compass')) setAttr(lnk, 'rcompass', getAttr(r, 'compass'));

    getDefaultAttribute(yy, 'linkcolor', function (linkColor) {
        lnk.setColor(linkColor);
    });
    getDefaultAttribute(yy, 'linktextcolor', function (linkColor) {
        lnk.setTextColor(linkColor);
    });
    if (commonLinkLabel != undefined) {
	lnk.setLabel(commonLinkLabel);
	debug("  set commonLinkLabel "+commonLinkLabel);
    }
    if (inlineLinkLabel != undefined) {
	lnk.setLabel(inlineLinkLabel);
	debug("  set inlineLinkLabel "+inlineLinkLabel);
    }
    else if (r instanceof Node && commonLinkLabel != undefined ) {
	lnk.setLabel(commonLinkLabel);
	debug('  set commonLinkLabel '+commonLinkLabel);
    }
    if (r instanceof Node) {
	tmp=r.getLinkLabel();
	if (tmp != undefined ) {
	    lnk.setLabel(tmp);
	    debug('  reset link label to '+tmp);
	}
    }
    if (linkColor != undefined) lnk.setColor(linkColor);

    if (!dontadd) {
	addLink(yy, lnk);
    }
    debug(false);
    return lnk;
}

/**
 * Add link to the list of links, return the LINK
 * @param yy lexer
 * @param l Link (Array or Link)
 */
function addLink(yy, l) {
    if (l instanceof Array) {
        debug("PUSH LINK ARRAY:" + l,true);
    } else {
        debug("PUSH LINK:" + l,true);
        setAttr(l, 'container', getCurrentContainer(yy));
    }
    yy.LINKS.push(l);
    debug(false);
    return l;
}

/**
 * Push given object into a current container
 */
function pushObject(yy, o) {
    var cnt = getCurrentContainer(yy)
    debug("pushObject " + o + "to " + cnt,true);
    cnt.OBJECTS.push(o);
    cnt.ROOTNODES.push(o);
    debug(false);
    return o;
}


//noinspection JSUnusedGlobalSymbols
/**
 * test if container has the object
 */
function containsObject(container, o) {
    for (var i in container.OBJECTS) {
        if (!container.OBJECTS.hasOwnProperty(i))continue;
        var c = container.OBJECTS[i];
        if (c == o) {
            return true;
        }
        if (c instanceof Group) {
            if (containsObject(c, o)) {
                return true;
            }
        }
    }
    return false;
}

function traverseLinks(yy, callback) {
    for (var i in yy.LINKS) {
	if (!yy.LINKS.hasOwnProperty(i)) continue;
	callback(yy.LINKS[i]);
    }
}

function traverseObjects(container, callback) {
    for (var i in container.OBJECTS) {
	if (!container.OBJECTS.hasOwnProperty(i)) continue;
	callback(container.OBJECTS[i]);
    }
}


Node.prototype = new GraphObject();
Node.prototype.constructor = Node;

/**
 * Construct a new node
 *
 * @param name Name of the node
 * @param [shape] Optional shape for the node, if not give, will default to what ever default is being used at the moment
 * @constructor
 */
function Node(name, shape) {
    this.name = name;
    this.shape = shape;
    this.image=undefined;
    this.style=undefined;
    this.setShape = function (value) {
        if (value === undefined) return this;
        if (value) value = value.toLowerCase();
        return setAttr(this, 'shape', value);
    };
    //noinspection JSUnusedGlobalSymbols
    this.getShape = function () {
        return getAttr(this, 'shape');
    };
    // temporary for RHS list array!!
    this.setLinkLabel = function (value) {
        return setAttr(this, 'linklabel', value);
    };
    this.getLinkLabel = function () {
        $tmp = getAttr(this, 'linklabel');
        setAttr(this, 'linklabel', undefined);
        return $tmp;
    };
    this.setStyle = function (value) {
        if (value === undefined) return this;
        if (value) value = value.toLowerCase();
        return setAttr(this, 'style', value);
    };
    //noinspection JSUnusedGlobalSymbols
    this.getStyle = function () {
        return getAttr(this, 'style');
    };
    this.setImage = function (value) {
        if (value === undefined) return this;
        return setAttr(this, 'image', value);
    };
    //noinspection JSUnusedGlobalSymbols
    this.getImage = function () {
        return getAttr(this, 'image');
    };
    this.toString = function () {
	var fmt = "";
	var tmp = getAttrFmt(this, 'color','');
	if (tmp !== undefined && tmp!='')
	    fmt += ",color: " + tmp;
	tmp = getAttrFmt(this, 'label','');
	if (tmp !== undefined && tmp!='')
	    fmt += ",label: " + tmp;
        return "Node(name:" + this.getName() +fmt+ ")";
    };
}
function getShape(shapes, o, fmt) {
    if (o == undefined || o == 0) return "";
    o = o.toLowerCase();
    if (o in shapes)
        return ' ' + fmt.format(shapes[o]) + ' ';
    else
        return ' ' + fmt.format(shapes['default']) + ' ';
}

var shapes = {
    blockdiag: {
        default: "box",
        invis: "invis",
        /* TODO? */
        record: "box",
        doublecircle: "endpoint",
        box: "box",
        rect: "box",
        rectangle: "box",
        square: "square",
        roundedbox: "roundedbox",
        dots: "dots",
        circle: "circle",
        ellipse: "ellipse",
        diamond: "diamond",
        minidiamond: "minidiamond",
        note: "note",
        mail: "mail",
        cloud: "cloud",
        actor: "actor",
        beginpoint: "flowchart.beginpoint",
        endpoint: "flowchart.endpoint",
        condition: "flowchart.condition",
        database: "flowchart.database",
        terminator: "flowchart.terminator",
        input: "flowchart.input",
        loopin: "flowchart.loopin",
        loop: "flowchart.loopin",
        loopstart: "flowchart.loopin",
        loopout: "flowchart.loopout",
        loopend: "flowchart.loopout"
    },
    actdiag: {
        default: "box",
        invis: "invis",
        /* TODO? */
        record: "box",
        doublecircle: "endpoint",
        box: "box",
        rect: "box",
        rectangle: "box",
        square: "square",
        roundedbox: "roundedbox",
        dots: "dots",
        circle: "circle",
        ellipse: "ellipse",
        diamond: "diamond",
        minidiamond: "minidiamond",
        note: "note",
        mail: "mail",
        cloud: "cloud",
        actor: "actor",
        beginpoint: "flowchart.beginpoint",
        endpoint: "flowchart.endpoint",
        condition: "flowchart.condition",
        database: "flowchart.database",
        terminator: "flowchart.terminator",
        input: "flowchart.input",
        loopin: "flowchart.loopin",
        loop: "flowchart.loopin",
        loopstart: "flowchart.loopin",
        loopout: "flowchart.loopout",
        loopend: "flowchart.loopout"
    },
    digraph: {
        default: "box",
        invis: "invis",
        record: "record",
        doublecircle: "doublecircle",
        box: "box",
        rect: "box",
        rectangle: "box",
        square: "square",
        roundedbox: "box",
        dots: "point",
        circle: "circle",
        ellipse: "ellipse",
        diamond: "diamond",
        minidiamond: "Mdiamond",
        minisquare: "Msquare",
        note: "note",
        mail: "tab",
        cloud: "tripleoctagon",
        actor: "cds",
        beginpoint: "circle",
        endpoint: "doublecircle",
        condition: "Mdiamond",
        database: "Mcircle",
        terminator: "ellipse",
        input: "parallelogram",
        loopin: "house",
        loop: "house",
        loopstart: "house",
        loopout: "invhouse",
        loopend: "invhouse"
    }
};
//SubGraph.prototype = new GraphObject();
SubGraph.prototype = new Group();
SubGraph.prototype.constructor = SubGraph;

/**
 * Create a new container SubGraph
 * @param name Name of the container
 * @constructor
 */
function SubGraph(name) {
    this.name = name;
    this.OBJECTS = [];
    this.ROOTNODES = [];
    this.isSubGraph=true;
    // temporary for RHS list array!!
    this.setLinkLabel = function (value) {
        return setAttr(this, 'linklabel', value);
    };
    this.getLinkLabel = function () {
        return getAttr(this, 'linklabel');
    };
    /**
     * Set default nodecolor, groupcolor, linkcolor Always ask from the
     * currentContainer first
     */
    this.setDefault = function (key, value) {
        //debug("Set SubGraph " + key + " to " + value);
        return setAttr(this, key, value);
    };
    this.setEntrance = function (entrance) {
        debug("subgraph:Set entrance to " + entrance);
        return setAttr(this, 'entrance', entrance);
    }; 
    this.getEntrance = function () {
        return getAttr(this, 'entrance');
    }; 
    this.setExit = function (exit) {
        debug("subgraph:Set exit to " + exit);
        return setAttr(this, 'exit', exit);
    };
    this.getExit = function () {
        return getAttr(this, 'exit');
    }; 
    this.getDefault = function (key) {
        //debug("subgrah:Get SubGraph " + key);
        return getAttr(this, key);
    };
    this.toString = function () {
	var fmt = "";
	if (this.linklabel !== undefined && this.linklabel!='') fmt+=",linklabel:"+this.linklabel;
	if (this.entrance !== undefined) fmt+=",entrance:"+this.entrance;

	if (this.exit !== undefined) fmt+=",exit:"+this.exit;
	if (this.ROOTNODES !== undefined) fmt+=",rootnodes:"+this.ROOTNODES;
        return "SubGraph(name:" + this.name + fmt+")";
    };
}
debugIndent=0;
/**
 * Simple debugger, uses console.log
 */
function debug(msg, indentOrDedent) {
    if (VERBOSE == true && msg!==false && msg!==true){
        var d="";
        for(var i=0;i<debugIndent;i++) d+="    ";
        console.log(d+msg);
    }
    if (indentOrDedent===true || msg===true){
      debugIndent++;
    }else if (indentOrDedent===false || msg===false){
      debugIndent--;
    }
}
/**
 * Set attribute of an object
 *
 * @param cl Object
 * @param attr Attribute name
 * @param value Value
 * @returns Object itself(cl)
 */
function setAttr(cl, attr, value) {
    cl[attr] = value;
    return cl;
}

/**
 * Create string formatter. Format string according to format rules with positional arguments like xxx={0} yyy={1}
 * @returns {String}
 */
String.prototype.format = function () {
    var formatted = this;
    for (var arg in arguments) {
        formatted = formatted.replace("{" + arg + "}", arguments[arg]);
    }
    return formatted;
};
String.prototype.formatArray = function (arra) {
    var formatted = this;
      for (var i=0;i<arra.length;i++) {
        formatted = formatted.replace("{" + i + "}", arra[i]);
    }
    return formatted;
};
/**
 * Return attribute like prefix="ATTRHERE" with padding at both sides or "" if 0
 * or undefined
 * @param cl Object to scan
 * @param attr Name of the attribute index to return
 */
function getAttr(cl, attr) {
    if (cl[attr] === undefined || cl[attr] == 0)
        return undefined;
    return cl[attr];
}

/**
 * Return formatted attribute value
 *
 * @param cl Object to scan thru
 * @param attr Name of the attribute to return
 * @param fmt Format string to apply to returned variable (optional), example: fillcolor="{0}"
 * @param [resultarray] If given, in addition for returning, will PUSH the result to this array
 * @returns (possibly formatted) value of the attribute or "" if attribute not found
 */
function getAttrFmt(cl, attr, fmt, resultarray) {
    var tmp;
    if (attr instanceof Array) {
        for (var i in attr) {
            if (!attr.hasOwnProperty(i))continue;
            // debug("Get FMT attr "+attr[i]+" from "+cl);
            tmp = getAttrFmt(cl, attr[i], fmt, resultarray);
            if (tmp !== "") {
                debug("Return " + tmp);
                return tmp;
            }
        }
        return "";
    }
    if (cl[attr] == undefined || cl[attr] == 0)
        return "";
    tmp = fmt.format(cl[attr]);
    if (resultarray)
        resultarray.push(tmp);
    return " " + tmp + " ";
}

var indentLevel=0;
function output(yy, txt, indentOrDedent) {
    var prefix="";
    if (txt!== true && txt!==false && yy !== true && yy!==false){
	for (var i = 0; i < indentLevel; i++) {
            prefix += "    ";
	}
	yy.result(prefix + txt);
    }
    if (indentOrDedent===true || yy===true || txt===true){
	indentLevel++;
    }else if (indentOrDedent===false || yy===false || txt===false){
	indentLevel--;
    }
}

function outputFmt(yy, txt, a) {
    if (a === undefined)
	yy.result(txt);
    else
	yy.result(txt.formatArray(a));
}
TreeNode.prototype.constructor = TreeNode
/**
 * Create a new tree node with data
 * @constructor
 */
function TreeNode(data) {
    this.CHILDREN = [];
    this.data = data;
    this.toString = function () {
        return "tree("+
	    data+
	    ",children=["+
	    JSON.stringify(this.data)+
	    "])";
    };
}

/**
 * Find a tree node from a tree if one exists
 * (with matching data)
 */
function findNode(tree, findData) {
    if(tree.data === findData){
	return tree;
    }
    for(var i in tree.CHILDREN){
	if (!tree.CHILDREN.hasOwnProperty(i)) continue;
	var tn = tree.CHILDREN[i];
	if(tn.data === findData){
	    return tn;
	}
	if (tn.CHILDREN.length>0){
	    var tmp = findNode(tn, findData);
	    if (tmp !== undefined) {
		return tmp;
	    }
	}
    }
    return undefined;
}

function traverseTree(root, callback, enter, exit, level, hasSibling,parent) {
    //debug('process node '+root.data.name + ' childmount'+siblingAmount);
    if (level===undefined) level=0;
    if (hasSibling===undefined) hasSibling=false;
    if (level===0) {
	callback(root, root.CHILDREN.length===0,false);
    }
    if (root.CHILDREN.length>0) {
	enter(root);
    }
    for(var i in root.CHILDREN){
	if (!root.CHILDREN.hasOwnProperty(i)) continue;
	var tn = root.CHILDREN[i];
	var isLeaf = tn.CHILDREN.length===0;
	var hasNodeSiblings = (parseInt(i)+1)!==root.CHILDREN.length;
	debug('node '+tn.data.name+' is leaf?'+isLeaf+" hasSiblings"+hasNodeSiblings+" i="+(parseInt(i)+1)+"/");
	callback(tn, isLeaf, hasNodeSiblings);
	if (tn.CHILDREN.length>0){
	    traverseTree(tn, 
			 callback, enter, exit,
			 level+1,
			 hasNodeSiblings,
			 root);
	}
    }
    if (root.CHILDREN.length>0) {
	debug(root.data.name+="has sibling");
	exit(root, hasSibling);
    }
}
//node parse.js state2.txt actdiag |actdiag -Tpng -o a.png - && open a.png

function actdiag(yy) {
    output(yy,"actdiag{\n  default_fontsize = 14");
    var r = getGraphRoot(yy);
    /*
     * does not really work..but portrait mode if
     * (r.getDirection()==="portrait"){ output(yy," orientation=portrait");
     * }else{ //DEFAULT output(yy," orientation=landscape"); }
     */
    //var s = r.getStart();
    var i;
    var parseObjects = function (o) {
	output(true);
        if (o instanceof Group) {
            output(yy,'lane "' + o.getName() + '"{',true);
	    traverseObjects(o, function(z){
                var s1 = getAttrFmt(z, 'color', ',color="{0}"') + 
		    getShape(shapes.actdiag, z.shape, ',shape={0}') + 
		    getAttrFmt(z, 'label', ',label="{0}"');
                if (s1.trim() != "") {
                    s1 = "[" + s1.trim().substring(1) + "]";
		}
                output(yy, z.getName() + s1 + ';');
            });
	    output(false);
            output(yy,"}");
        } else {
            // dotted,dashed,solid
            // NOT invis,bold,rounded,diagonals
            // ICON does not work, using background
            var style = getAttrFmt(o, 'style', ',style="{0}"');
            if (style != "" && style.match(/(dotted|dashed|solid)/) == null) {
                style = "";
            }

            // ICON does not work, using background
            var s2 = getAttrFmt(o, 'color', ',color="{0}"') +
		getAttrFmt(o, 'image', ',background="icons{0}"') +
		style +
		getShape(shapes.actdiag, o.shape, ',shape={0}') +
		getAttrFmt(o, 'label', ',label="{0}"');
            if (s2.trim() != "")
                s2 = "[" + s2.trim().substring(1) + "]";
            output(yy,o.getName() + s2 + ';');
        }
	output(false);
    };
    traverseObjects(r, parseObjects);

    traverseLinks(yy, function(l) {
        var t = "";
        if (l.linkType.indexOf(".") !== -1) {
            t += ',style="dotted" ';
        } else if (l.linkType.indexOf("-") !== -1) {
            t += ',style="dashed" ';
        }
        var lbl = getAttrFmt(l, 'label', ',label = "{0}"' + getAttrFmt(l, ['color', 'textcolor'], 'textcolor="{0}"'));
        var color = getAttrFmt(l, 'color', ',color="{0}"');
        t += lbl + color;
        t = t.trim();
        if (t.substring(0, 1) == ",")
            t = t.substring(1).trim();
        if (t != "")
            t = "[" + t + "]";
        output(yy,"  " + l.left.getName() + " -> " + l.right.getName() + t + ";");
    });
    output(yy,"}");
}
function ast(yy) {
    var processANode = function (o) {
    };

    output(yy, "{");
    var skipEntrances = function (key,value) {
        if (key === 'entrance' || key === 'exit') {
            return value;
        }
        return value;
    };    
    var r = getGraphRoot(yy);
    if (r.getVisualizer())
        output(yy, JSON.stringify({
            visualizer: r.getVisualizer()
        }));
    if (r.getDirection())
        output(yy, JSON.stringify({
            direction: r.getDirection()
        }));
    if (r.getStart())
        output(yy, JSON.stringify({
            start: r.getStart()
        }));
    if (r.getEqual())
        output(yy, JSON.stringify({
            equal: r.getEqual()
        }));

    var objectHandler = function(o) {
	output(true);
        if (o instanceof Group) { 
            var processAGroup = function (o) {
                var n = JSON.parse(JSON.stringify(o, skipEntrances));
                n.OBJECTS = undefined;
                output(yy, JSON.stringify({
                    group: n
                })+",");
                output(yy, '{');
                traverseObjects(o, objectHandler);
                output(yy, '},');
            }(o);
        } else if (o instanceof SubGraph) {
            var processASubGraph = function (o) {
                var n = JSON.parse(JSON.stringify(o, skipEntrances));
                n.OBJECTS = undefined;
                output(yy, JSON.stringify({
                    subgraph: n
                })+",");
                output(yy, '{');
                traverseObjects(o, objectHandler);
                output(yy, '},');
            }(o);
        } else if (o instanceof Node) {
            output(yy, JSON.stringify({
                node: o
            })+",");
        } else {
            throw new Error("Not a node nor a group, NOT SUPPORTED");
        }
	output(false);
    };
    traverseObjects(r,objectHandler);

    output(true);
    traverseLinks(yy, function (l) {
        var n = JSON.parse(JSON.stringify(l, skipEntrances));
        n.left = n.left.name;
        n.right = n.right.name;
        n.container.OBJECTS = undefined;
        n.container.label = undefined;
        n.container.isSubGraph = undefined;
        n.container.entrance = n.container.entrance?n.container.entrance.name:undefined;
        n.container.exitnode = n.container.exitnode?n.container.exitnode.name:undefined;
        n.container.conditional = undefined;
        n.container = n.container.name;
        output(yy, JSON.stringify({link:n})+",");
    });
    output(false);
    output(yy, "}",false);
}
//http://blockdiag.com/en/blockdiag/examples.html#simple-diagram
//node parse.js state2.txt blockdiag |blockdiag -Tpng -o a.png - && open a.png
//available shapes
//box,square,roundedbox,dots
//circle,ellipse,diamond,minidiamond
//note,mail,cloud,actor
//flowchart.beginpoint,flowchart.endpoint
//flowchart.condition,flowchart.database,flowchart.terminator,flowchart.input
//flowchart.loopin,flowchart.loopout

function blockdiag(yy) {
    output(yy,"blockdiag{\n default_fontsize = 14");
    var r = getGraphRoot(yy);
    if (r.getDirection() === "portrait") {
        output(yy,"  orientation=portrait");
    } else {
        // DEFAULT
        output(yy,"  orientation=landscape");
    }
    var i;
    var tmp = r.getStart();
    var parseObjects = function(o){
	output(true);
        if (o instanceof Group) {
            output(yy,' group "' + o.getLabel() + '"{',true);
            output(yy,getAttrFmt(o, 'color', '   color="{0}"'));
            output(yy,getAttrFmt(o, 'label', '   label="{0}"'));
            if (tmp !== undefined && tmp.trim() != "")
                tmp = "[" + tmp.trim().substring(1) + "]";
	    traverseObjects(o,function(z){
                tmp = getAttrFmt(z, 'color', ',color="{0}"') +
		    getShape(shapes.blockdiag, z.shape, ',shape={0}') +
		    getAttrFmt(z, 'label', ',label="{0}"');
                if (tmp.trim() != "")
                    tmp = "[" + tmp.trim().substring(1) + "]";
                output(yy, z.getName() + tmp + ';');
            });
	    output(false);
            output(yy,"}");
        } else {
            // dotted,dashed,solid
            // NOT invis,bold,rounded,diagonals
            // ICON does not work, using background
            var style = getAttrFmt(o, 'style', ',style="{0}"');
            if (style != "" && style.match(/(dotted|dashed|solid)/) == null) {
                style = "";
            }

            var s = getAttrFmt(o, 'color', ',color="{0}"') +
		getAttrFmt(o, 'image', ',background="icons{0}"') +
		style +
		getShape(shapes.blockdiag, o.shape, ',shape="{0}"') +
		getAttrFmt(o, 'label', ',label="{0}"');
            if (s.trim() != "")
                s = "[" + s.trim().substring(1) + "]";
            output(yy,o.getName() + s + ';');
        }
	output(false);
    };

    traverseObjects(r, parseObjects);

    traverseLinks(yy,function(l) {
        var t = "";
        if (l.linkType.indexOf(".") !== -1) {
            t += ',style="dotted" ';
        } else if (l.linkType.indexOf("-") !== -1) {
            t += ',style="dashed" ';
        }
        var lbl = getAttrFmt(l, 'label', ',label = "{0}"' + getAttrFmt(l, ['color', 'textcolor'], 'textcolor="{0}"'));
        var color = getAttrFmt(l, 'color', ',color="{0}"');
        t += lbl + color;
        t = t.trim();
        if (t.substring(0, 1) == ",")
            t = t.substring(1).trim();
        if (t != "")
            t = "[" + t + "]";
        output(yy,"  " + l.left.getName() + " -> " + l.right.getName() + t + ";");
    });
    output(yy,"}");
}
function dendrogram(yy) {
    var tree;
    function addNode(l, r) {
	if (tree === undefined) {
	    tree = new TreeNode(l);
	}
	if (!(l instanceof Node)) return;
	var cl = findNode(tree,l);
	if (cl===undefined){
	    throw new Error('Left node ('+l.name+') not found from tree');
	}
	if (undefined === findNode(tree,r) && (r instanceof Node)){
	    debug('Add '+r.name+' as child of '+cl.data.name+" co "+r.container);
	    cl.CHILDREN.push(new TreeNode(r));
	}
    }

    //debug(JSON.stringify(yy.LINKS));
    /**
     * For a dendrogram we're not interested in nodes
     * just edges(for now!)
     */
    traverseLinks(yy, function(l) {
	//debug('link node '+l.left.name+' to '+l.right.name);
	addNode(l.left, l.right);
    });

    //output(yy,'{',true);
    traverseTree(tree,function (t, isLeaf, hasSibling) {
	if (isLeaf){
	    comma='';
	    if (hasSibling)
		comma=',';
	    output(yy,'{"name": "'+t.data.name+'", "size": 1}'+comma);
	}else{
	    output(yy,'{',true);
	    output(yy,'"name": "'+t.data.name+'",');
	}
    },function(t){
	output(yy,'"children": [',true);
    },function(t, hasNextSibling){
	output(false);
	output(yy,']',false);
	if (hasNextSibling){
	    output(yy,'},');
	}else{
	    output(yy,'}');
	}
    });
    output(false);
}
function dexgraph(yy) {
    var depth = 0;

    function indent(msg) {
        if (msg.trim() == "")
            return "";
        var prefix = "";
        for (var i = 0; i < depth; i++) {
            prefix += "  ";
        }
        return (prefix + msg).trim();
    }

    var processANode = function (o) {
        var nattrs = [];
        var styles = [];
        getAttrFmt(o, 'color', 'fillcolor="{0}"', nattrs);
        getAttrFmt(o, 'color', 'filled', styles);
        getAttrFmt(o, 'style', '{0}', styles);
        var url = getAttr(o, 'url');
        if (url) {
            nattrs.push('"[[' + url.trim() + ']]"');
        }
        if (styles.length > 0) {
            if (styles.join("").indexOf('singularity') !== -1) {
                // invis node is not singularity!, circle with minimal
                // width/height IS!
                nattrs.push('circle');
            } else {
                nattrs.push(styles.join(","));
            }
        }
        getAttrFmt(o, 'image', 'image="icons{0}"', nattrs);
        getAttrFmt(o, 'textcolor', 'fontcolor="{0}"', nattrs);
        getAttrFmt(o, 'label', '"{0}"', nattrs);
        var t = "";
        if (nattrs.length > 0)
            t =  nattrs.join(",");
        yy.result(indent('t_'+o.getName() + ' ' + o.getName() + ' ' + t));
    };

    var processAType = function (o) {
        var nattrs = [];
        var styles = [];
        getAttrFmt(o, 'color', '"{0}"', nattrs);
        //getAttrFmt(o, 'style', '{0}', styles);
        //if (styles.length > 0) {
        //    nattrs.push('"' + styles.join(",") + '"');
        //}
        //getAttrFmt(o, 'image', 'image="icons{0}"', nattrs);
        //getAttrFmt(o, 'textcolor', 'f"{0}"', nattrs);
        var r = getShape(shapes.digraph, o.shape, '{0}');
        if (r) {
            nattrs.push(r);
        } else {
            nattrs.push('circle');
        }
        var t = "";
        if (nattrs.length > 0)
            t = nattrs.join("|");
        yy.result(indent('(type t_' + o.getName() + t+')'));
    };

    var r = getGraphRoot(yy);
    if (r.getVisualizer()) {
        yy.result("/* render:" + r.getVisualizer() + "*/")
    }
    yy.result("GRAPH:");
    depth++;
	yy.result('fff');
    var fixgroup = function (c) {
        for (var i in c.OBJECTS) {
            if (!c.OBJECTS.hasOwnProperty(i))continue;
            var o = c.OBJECTS[i];
            if (o instanceof Group) {
                if (o.OBJECTS.length == 0) {
                    o.OBJECTS.push(new Node("invis_" + o.getName())
                        .setStyle("invis"));
                } else {
                    // A group...non empty...parse inside
                    fixgroup(o);
                }
            }
        }
    }(r.OBJECTS);
	yy.result('zzz');

    function getFirstLink(grp) {
        // yy.result("FIRST NODE"+JSON.stringify(grp));
        for (var i in yy.LINKS) {
            if (!yy.LINKS.hasOwnProperty(i))continue;
            var l = yy.LINKS[i];
            for (var j in grp.OBJECTS) {
                if (!grp.OBJECTS.hasOwnProperty(j))continue;
                var n = grp.OBJECTS[j];
                if (n == l.left) {
                    // yy.result("ReturnF "+n);
                    return n;
                }
            }
        }
        return undefined;
    }
	yy.result('xxx');

    function getLastLink(grp) {
        var nod = undefined;
        // yy.result("LAST NODE"+JSON.stringify(grp));
        for (var i in yy.LINKS) {
            if (!yy.LINKS.hasOwnProperty(i))continue;
            var l = yy.LINKS[i];
            for (var j in grp.OBJECTS) {
                if (!grp.OBJECTS.hasOwnProperty(j))continue;
                var n = grp.OBJECTS[j];
                if (n == l.left)
                    nod = n;
                if (n == l.right)
                    nod = n;
            }
        }
        return nod;
    }

	yy.result('+++');
    var dumpTypes = function traverseObjects(r) {
        for (var i in r.OBJECTS) {
            if (!r.OBJECTS.hasOwnProperty(i))continue;
            var o = r.OBJECTS[i];
            if (o instanceof Group) {
            } else if (o instanceof Node) {
                processAType(o);
            } else {
                throw new Error("Not a node nor a group, NOT SUPPORTED");
            }
        }
    }(r);
	yy.result('----');

    var lastexit = undefined;
    var lastendif = undefined;
    var traverseObjects = function traverseObjects(r) {
        for (var i in r.OBJECTS) {
            if (!r.OBJECTS.hasOwnProperty(i))continue;
            var o = r.OBJECTS[i];
            if (o instanceof Group) {
                var cond = getAttr(o, 'conditional');
                var processAGroup = function (o) {
                    debug(JSON.stringify(o));
                    yy.result(indent('subgraph cluster_' + o.getName() + ' {'));
                    if (o.isSubGraph){
                        yy.result('graph[style=invis];');
                    }
                    depth++;
                    if (o.getLabel())
                        yy.result(indent(getAttrFmt(o, 'label',
                            '   label="{0}";')));
                    if (o.getColor() !== undefined) {
                        yy.result(indent("style=filled;"));
                        yy.result(indent(getAttrFmt(o, 'color',
                            '   color="{0}";\n')));
                    }
                    depth++;
                    traverseObjects(o);
                    depth--;
                    depth--;
                    yy.result(indent("}//3end of " + o.getName() + " " + cond));
                    if (cond) {
                        yy.result(indent("//COND " + o.getName() + " " + cond));
                        if (cond == "endif") {
                            //never reached
                            var exitlink = getAttr(o, 'exitlink');
                            if (exitlink) {
                                yy.result(indent(lastexit + "->" + exitlink + "[color=red];"));
                                yy.result(indent(lastendif + "->" + exitlink + ";"));
                            }
                        } else {
                            var sn = "entry" + getAttr(o, 'exitnode');
                            if (!lastendif) {
                                lastendif = "endif" + getAttr(o, 'exitnode');
                                yy.result(indent(lastendif + "[shape=circle,label=\"\",width=0.01,height=0.01];"));
                            }
                            //TODO:else does not need diamond
                            yy.result(indent(sn + "[shape=diamond,fixedsize=true,width=1,height=1,label=\"" + o.getLabel() + "\"];"));
                            if (cond == "if") {
                                //entrylink!
                                yy.result(indent(getAttr(o, 'entrylink').getName() + "->" + sn + ";"));
                            }
                            // FIRST node of group and LAST node in group..
                            var fn = getFirstLink(o);
                            var ln = getLastLink(o);
                            // decision node
                            //var en = "exit" + getAttr(o, 'exitnode');

                            if (lastexit) {
                                yy.result(indent(lastexit + "->" + sn + "[label=\"NO\",color=red];"));
                                //lastexit = undefined;
                            }
                            // YES LINK to first node of the group
                            yy.result(indent(sn + "->" + fn.getName() + "[label=\"YES\",color=green,lhead=cluster_" + o.getName() + "];"));
                            yy.result(indent(ln.getName() + "->" + lastendif + "[label=\"\"];"));
                            lastexit = sn;
                        }
                    }
                }(o);
            } else if (o instanceof Node) {
                processANode(o);
            } else {
                throw new Error("Not a node nor a group, NOT SUPPORTED");
            }
        }
    }(r);

    yy.result("//links start");
    for (var i in yy.LINKS) {
        if (!yy.LINKS.hasOwnProperty(i))continue;
        var l = yy.LINKS[i];
        var attrs = [];
        var label = getAttr(l, 'label');
        if (label) {
            if (label.indexOf("::") !== -1) {
                label = label.split("::");
                attrs.push('label="' + label[0].trim() + '"');
                attrs.push('xlabel="' + label[1].trim() + '"');
            } else {
                attrs.push('label="' + label.trim() + '"');
            }
        }
        var url = getAttr(l, 'url');
        if (url) {
            attrs.push('URL="' + url.trim() + '"');
        }
        getAttrFmt(l, 'color', 'color="{0}"', attrs);
        getAttrFmt(l, ['textcolor', 'color'], 'fontcolor="{0}"', attrs);
        var lt;
        var lr = l.right;
        var ll = l.left;

        // yy.result(indent("//"+lr));
        if (lr instanceof Group ) {
            // just pick ONE Node from group and use lhead
            // TODO: Assuming it is Node (if Recursive groups implemented, it
            // could be smthg else)
            if (!lr.isSubGraph)
                attrs.push(" lhead=cluster_" + lr.getName());
            lr = lr.OBJECTS[0];
            if (lr == undefined) {
                // TODO:Bad thing, EMPTY group..add one invisible node there...
                // But should add already at TOP
            }
        }
        if (ll instanceof Group) {
            if (!ll.isSubGraph)
                attrs.push(" ltail=cluster_" + ll.getName());
            ll = ll.OBJECTS[0];
            if (ll == undefined) {
                // Same as above
            }
        }
        // TODO:Assuming producing DIGRAPH
        // For GRAPH all edges are type --
        // but we could SET arrow type if we'd like
        if (l.linkType.indexOf(".") !== -1) {
            attrs.push('style="dotted"');
        } else if (l.linkType.indexOf("-") !== -1) {
            attrs.push('style="dashed"');
        }
        if (l.linkType.indexOf("/") !== -1) {
            // TODO: Somehow denote better this "quite does not reach"
            // even though such an edge type MAKES NO SENSE in a graph
            attrs.push('arrowhead="tee"');
        }
        if (l.linkType.indexOf("<") !== -1 && l.linkType.indexOf(">") !== -1) {
            lt = "->";
            attrs.push("dir=both");
        } else if (l.linkType.indexOf("<") !== -1) {
            var tmp = ll;
            ll = lr;
            lr = tmp;
            lt = "->";
        } else if (l.linkType.indexOf(">") !== -1) {
            lt = "->";
        } else {
            // is dotted or dashed no direction
            lt = "->";
            attrs.push("dir=none");
        }
        var t = "";
        if (attrs.length > 0)
            t = "[" + attrs.join(",") + "]";
        yy.result(indent(ll.getName() + getAttrFmt(l, 'lcompass', '{0}').trim() + lt + lr.getName() + getAttrFmt(l, 'rcompass', '{0}').trim() + t + ";"));
    }
    yy.result("}");
}
function digraph(yy) {
    // TODO: See splines control
    // http://www.graphviz.org/doc/info/attrs.html#d:splines
    // TODO: Start note fdp/neato
    // http://www.graphviz.org/doc/info/attrs.html#d:start

    var skipEntrances = function (key,value) {
        if (key === 'entrance' || key === 'exit') {
            return null;
        }
        return value;
    };

    function hasOutwardLink(yy,node) {
	for (var i in yy.LINKS) {
            if (!yy.LINKS.hasOwnProperty(i))continue;
            var r = yy.LINKS[i];
            if (r.left.name === node.name){
		return true;
            }
	}
	return false;
    }
    
    var processANode = function (o) {
        var nattrs = [];
        var styles = [];
        getAttrFmt(o, 'color', 'fillcolor="{0}"', nattrs);
        getAttrFmt(o, 'color', 'filled', styles);
        getAttrFmt(o, 'style', '{0}', styles);
        // if (getAttr(o,'free')===true){
        // nattrs.push("constraint=false");
        // }
        var url = getAttr(o, 'url');
        if (url) {
            nattrs.push('URL="' + url.trim() + '"');
        }
        if (styles.length > 0) {
            if (styles.join("").indexOf('singularity') !== -1) {
                // invis node is not singularity!, circle with minimal
                // width/height IS!
                nattrs.push('shape="circle"');
                nattrs.push('label=""');
                nattrs.push("width=0.01");
                nattrs.push("weight=0.01");
            } else {
                nattrs.push('style="' + styles.join(",") + '"');
            }
        }
        getAttrFmt(o, 'image', 'image="icons{0}"', nattrs);
        getAttrFmt(o, 'textcolor', 'fontcolor="{0}"', nattrs);
        var r = getShape(shapes.digraph, o.shape, 'shape="{0}"');
        if (r) {
            nattrs.push(r);
        }
        getAttrFmt(o, 'label', 'label="{0}"', nattrs);
        var t = "";
        if (nattrs.length > 0)
            t = "[" + nattrs.join(",") + "]";
        output(yy,o.getName() + t + ';');
    };

    var r = getGraphRoot(yy);
    if (r.getVisualizer()) {
        output(yy,"/* render:" + r.getVisualizer() + "*/")
    }
    output(yy,"digraph {",true);
    //output(yy,"edge[weight=1]")
    //output(yy,"ranksep=0.75")
    //output(yy,"nodesep=0.75")

    output(yy,"compound=true;");
    if (r.getDirection() === "portrait") {
        output(yy,"rankdir=LR;");
    } else {
        output(yy,"rankdir=TD;");
    }
    // This may FORWARD DECLARE a node...which creates problems with coloring
    var s = r.getStart();
    if (s != undefined && s != "") {
        var fwd = getNode(yy, s);
        processANode(fwd);
        // {$$=" {rank = same;null}\n {rank = same; "+$2+"}\n null
        // [shape=plaintext,
        // label=\"\"];\n"+$2+"[shape=doublecircle];\nnull->"+$2+";\n";}
        output(yy, "//startnode setup\n  {rank = same;null} {rank = same; " + s + "}\n  null [shape=plaintext, label=\"\"];\n  " + s + "[shape=doublecircle];\n  null->" + s + ";\n");
    }
    // This may FORWARD DECLARE a node...which creates problems with coloring
    if (r.getEqual() != undefined && r.getEqual().length > 0) {
        output(yy,"{rank=same;",true);
        for (var x = 0; x < r.getEqual().length; x++) {
            output(yy,r.getEqual()[x].getName() + ";");
        }
        output(yy,"}",false);
    }
    var fixgroup = function (c) {
        for (var i in c.OBJECTS) {
            if (!c.OBJECTS.hasOwnProperty(i))continue;
            var o = c.OBJECTS[i];
            if (o instanceof Group) {
                if (o.OBJECTS.length == 0) {
                    o.OBJECTS.push(new Node("invis_" + o.getName())
                        .setStyle("invis"));
                } else {
                    // A group...non empty...parse inside
                    fixgroup(o);
                }
            }
        }
    }(r.OBJECTS);

    function getFirstLinkOfTheGroup(grp) {
        //output(yy,"FIRST NODE"+JSON.stringify(grp));
        for (var i in yy.LINKS) {
            if (!yy.LINKS.hasOwnProperty(i))continue;
            var l = yy.LINKS[i];
            for (var j in grp.OBJECTS) {
                if (!grp.OBJECTS.hasOwnProperty(j))continue;
                var n = grp.OBJECTS[j];
                if (n == l.left) {
                    // output(yy,"ReturnF "+n);
                    return n;
                }
            }
        }
        return undefined;
    }

    function getLastLinkInGroup(grp) {
        var nod = undefined;
        // output(yy,"LAST NODE"+JSON.stringify(grp));
        for (var i in yy.LINKS) {
            if (!yy.LINKS.hasOwnProperty(i))continue;
            var l = yy.LINKS[i];
            for (var j in grp.OBJECTS) {
                if (!grp.OBJECTS.hasOwnProperty(j))continue;
                var n = grp.OBJECTS[j];
                if (n == l.left)
                    nod = n;
                if (n == l.right)
                    nod = n;
            }
        }
        // output(yy,"ReturnL "+nod);
        return nod;
    }

    var lastexit = undefined;
    var lastendif = undefined;
    var traverseObjects = function traverseObjects(r) {
        for (var i in r.OBJECTS) {
            if (!r.OBJECTS.hasOwnProperty(i))continue;
            var o = r.OBJECTS[i];
            if (o instanceof Group) {
                var cond = getAttr(o, 'conditional');
                //	if (cond=="endif")continue;
                // Group name,OBJECTS,get/setEqual,toString
                var processAGroup = function (o) {
                    debug(JSON.stringify(o,skipEntrances));
                    output(yy,'subgraph cluster_' + o.getName() + ' {',true);
                    if (o.isSubGraph){
                        output(yy,'graph[style=invis];');
                    }
                    if (o.getLabel())
                        output(yy,getAttrFmt(o, 'label',
                            '   label="{0}";'));
                    if (o.getColor() !== undefined) {
                        output(yy,"style=filled;");
                        output(yy,getAttrFmt(o, 'color',
                            '   color="{0}";\n'));
                    }
                    traverseObjects(o);
		    output(false);
                    output(yy,"}//end of " + o.getName() + " " + cond);
                    if (cond) {
                        output(yy,"//COND " + o.getName() + " " + cond);
                        if (cond == "endif") {
                            //never reached
                            var exitlink = getAttr(o, 'exitlink');
                            if (exitlink) {
                                output(yy,lastexit + "->" + exitlink + "[color=red];");
                                output(yy,lastendif + "->" + exitlink + ";");
                            }
                        } else {
                            var sn = "entry" + getAttr(o, 'exitnode');
                            if (!lastendif) {
                                lastendif = "endif" + getAttr(o, 'exitnode');
                                output(yy,lastendif + "[shape=circle,label=\"\",width=0.01,height=0.01];");
                            }
                            //TODO:else does not need diamond
                            output(yy,sn + "[shape=diamond,fixedsize=true,width=1,height=1,label=\"" + o.getLabel() + "\"];");
                            if (cond == "if") {
                                //entrylink!
                                output(yy,getAttr(o, 'entrylink').getName() + "->" + sn + ";");
                            }
                            // FIRST node of group and LAST node in group..
                            var fn = getFirstLinkOfTheGroup(o);
                            var ln = getLastLinkInGroup(o);
                            // decision node
                            //var en = "exit" + getAttr(o, 'exitnode');

                            if (lastexit) {
                                output(yy,lastexit + "->" + sn + "[label=\"NO\",color=red];");
                                //lastexit = undefined;
                            }
                            // YES LINK to first node of the group
                            output(yy,sn + "->" + fn.getName() + "[label=\"YES\",color=green,lhead=cluster_" + o.getName() + "];");
                            output(yy,ln.getName() + "->" + lastendif + "[label=\"\"];");
                            lastexit = sn;
                        }
                    }
                }(o);
            } else if (o instanceof Node) {
                processANode(o);
            } else {
                throw new Error("Not a node nor a group, NOT SUPPORTED");
            }
        }
    }(r);

    output(yy,"//links start");
    for (var i in yy.LINKS) {
        if (!yy.LINKS.hasOwnProperty(i))continue;
        var l = yy.LINKS[i];
        var attrs = [];
        var label = getAttr(l, 'label');
        if (label) {
            if (label.indexOf("::") !== -1) {
                label = label.split("::");
                attrs.push('label="' + label[0].trim() + '"');
                attrs.push('xlabel="' + label[1].trim() + '"');
            } else {
                attrs.push('label="' + label.trim() + '"');
            }
        }
        var url = getAttr(l, 'url');
        if (url) {
            attrs.push('URL="' + url.trim() + '"');
        }
        getAttrFmt(l, 'color', 'color="{0}"', attrs);
        getAttrFmt(l, ['textcolor', 'color'], 'fontcolor="{0}"', attrs);
        var lt;
        var lr = l.right;
        var ll = l.left;

        //output(yy,"// link from "+ll+" to "+lr);
        if (lr instanceof Group ) {
            //debug('huuhuu');
            // just pick ONE Node from group and use lhead
            // TODO: Assuming it is Node (if Recursive groups implemented, it
            // could be smthg else)
            if (!lr.isSubGraph)
                attrs.push(" lhead=cluster_" + lr.getName());
            lr = lr.OBJECTS[0];
            //debug('lr is '+lr);
            if (lr == undefined) {
                // TODO:Bad thing, EMPTY group..add one invisible node there...
                // But should add already at TOP
            }
        }
        if (ll instanceof Group) {
            if (!ll.isSubGraph)
                attrs.push(" ltail=cluster_" + ll.getName());
            if (ll instanceof SubGraph && ll.getExit()!==undefined){
              //get containers all nodes that have no outward links...(TODO:should be in model actually!)
              //perhaps when linking SUBGRAPH to a node (or another SUBGRAPH which might be very tricky)
              var exits=[];
              for(var i in ll.OBJECTS){
               if (!ll.OBJECTS.hasOwnProperty(i))continue;
                var go = ll.OBJECTS[i];
                if (!hasOutwardLink(yy,go)){
                //debug('test node '+go);
                  exits.push(go);
                }
              }
              ll=exits;
              //debug('got '+exits);
            } else {
              ll = ll.OBJECTS[0];
            }
            //debug('ll is.. '+ll);
            //debug('lr is '+lr);
            if (ll == undefined) {
                // Same as above
            }
        }
        // TODO:Assuming producing DIGRAPH
        // For GRAPH all edges are type --
        // but we could SET arrow type if we'd like
        if (l.linkType.indexOf(".") !== -1) {
            attrs.push('style="dotted"');
        } else if (l.linkType.indexOf("-") !== -1) {
            attrs.push('style="dashed"');
        }
        if (l.linkType.indexOf("/") !== -1) {
            // TODO: Somehow denote better this "quite does not reach"
            // even though such an edge type MAKES NO SENSE in a graph
            attrs.push('arrowhead="tee"');
        }
        if (l.linkType.indexOf("<") !== -1 && l.linkType.indexOf(">") !== -1) {
            lt = "->";
            attrs.push("dir=both");
        } else if (l.linkType.indexOf("<") !== -1) {
            var tmp = ll;
            ll = lr;
            lr = tmp;
            lt = "->";
        } else if (l.linkType.indexOf(">") !== -1) {
            lt = "->";
        } else {
            // is dotted or dashed no direction
            lt = "->";
            attrs.push("dir=none");
        }
        var t = "";
        if (attrs.length > 0)
            t = "[" + attrs.join(",") + "]";
        //debug('print ll '+ll);
        //debug('print lr '+lr);
        if (ll instanceof Array) {
          ll.forEach(function(element, index, array){
            output(yy,element.getName() + getAttrFmt(l, 'lcompass', '{0}').trim() + lt + lr.getName() + getAttrFmt(l, 'rcompass', '{0}').trim() + t + ";");
          });
        } else {
          output(yy,ll.getName() + getAttrFmt(l, 'lcompass', '{0}').trim() + lt + lr.getName() + getAttrFmt(l, 'rcompass', '{0}').trim() + t + ";");
        }
    }
    output(false);
    output(yy, "}");
}
function mscgen(yy) {
    output(yy,"msc {",true);
    var r = getGraphRoot(yy);
    var comma = false;
    var i;
    var tmp;
    // print out all node declarations FIRST (if any)
    traverseObjects(r, function(o){
        if (o instanceof Group) {
            output(yy,' /*' + o.getName() + getAttrFmt(o, 'label', ' {0}')+'*/');
	    traverseObjects(o,function(z){
                tmp = getAttrFmt(z, 'color', ',color="{0}"') + getAttrFmt(z, 'style', ',style={0}') + getAttrFmt(z, 'label', ',label="{0}"');
                if (tmp.trim() != "")
                    tmp = "[" + tmp.trim().substring(1) + "]";
                output(yy,(comma ? "," : "") + "    " + z.getName() + tmp);
                comma = true;
            });
        } else if (o instanceof Node) {
            tmp = getAttrFmt(o, 'color', ',textbgcolor="{0}"') + getAttrFmt(o, 'style', ',style={0}') + getAttrFmt(o, 'label', ',label="{0}"');
            if (tmp.trim() != "")
                tmp = "[" + tmp.trim().substring(1) + "]";
            output(yy,(comma ? "," : "") + "  " + o.getName() + tmp);
            comma = true;
        }
    });
    
    output(yy,";");
    var id = 1;
    traverseLinks(yy, function(l){
        var lt="";
        var lr = l.right;
        var ll = l.left;

        if (lr instanceof Group) {
            // just pick ONE Node from group and use lhead
            // TODO: Assuming it is Node (if Recursive groups implemented, it
            // could be smthg else)
            lt += " lhead=cluster_" + lr.getName();
            lr = lr.OBJECTS[0];
            if (lr == undefined) {
                // TODO:Bad thing, EMPTY group..add one invisible node there...
                // But should add already at TOP
            }
        }
        // TODO:Assuming producing DIGRAPH
        // For GRAPH all edges are type --
        // but we could SET arrow type if we'd like
        var rightName = lr.getName();

        var dot = false;
        var dash = false;
        var broken = false;
        if (l.linkType.indexOf(".") !== -1) {
            dot = true;
        } else if (l.linkType.indexOf("-") !== -1) {
            dash = true;
        } else if (l.linkType.indexOf("/") !== -1) {
            broken = true;
        }
        var swap = false;
        var attrs = [];
        var label = getAttr(l, "label");
        var color = getAttr(l, 'color');
        var url = getAttr(l, "url");
        var note = "";
        if (url) {
            attrs.push('URL="' + url + '"');
        }
        if (color) {
            attrs.push('linecolor="' + color + '"');
        }
        if (label) {
            if (label.indexOf("::") !== -1) {
                label = label.split("::");
                note = label[1].trim();
                attrs.push('label="' + label[0].trim() + '"');
            } else {
                attrs.push('label="' + label.trim() + '"');
            }
        }
        attrs.push('id="' + id++ + '"');
        if (l.linkType.indexOf("<") !== -1 && l.linkType.indexOf(">") !== -1) {
            // Broadcast type (<>)
            // hmh..since seqdiag uses a<>a as broadcast and
            // a<>b as autoreturn, could we do as well?
            if (ll == lr) {
                lt = "->";
                rightName = "*";
            } else {
                lt = "<=>";
                swap = true;
            }
        } else if (l.linkType.indexOf("<") !== -1) {
            var tmpl = ll;
            ll = lr;
            lr = tmpl;
            if (dot)
                lt = ">>";
            else if (dash)
                lt = "->";
            else if (broken)
                lt = "-x";
            else
                lt = "=>";
            rightName = lr.getName();
        } else if (l.linkType.indexOf(">") !== -1) {
            if (dot)
                lt = ">>";
            else if (dash)
                lt = "->";
            else if (broken)
                lt = "-x";
            else
                lt = "=>";
        } else if (dot) {
            // dotted
            if (color) {
                attrs.push('textcolor="' + color + '"');
            }
            output(yy,"...[" + attrs.join(",") + "];");
            return;
        } else if (dash) {
            // dashed
            if (color) {
                attrs.push('textcolor="' + color + '"');
            }
            output(yy,"---[" + attrs.join(",") + "];");
            return;
        } else {
            output(yy,"ERROR: SHOULD NOT HAPPEN");
        }

        output(yy,ll.getName() + lt + rightName + "[" + attrs.join(",") + "];");
        if (note != "")
        // output(yy,ll.getName() +' abox '
        // +lr.getName()+'[label="'+note+'"];');
            output(yy,lr.getName() + ' abox ' + lr.getName() + '[label="' + note + '"];');
        // if (swap)
        // output(yy,lr.getName() + lt + ll.getName() + t + ";");
    });
    output(false);
    output(yy,"}");
}
//node parse.js state2.txt actdiag |actdiag -Tpng -o a.png - && open a.png

function nwdiag(yy) {
    yy.result("nwdiag{\n default_fontsize = 16\n");
    var r = getGraphRoot(yy);
    //var s = r.getStart();
    var i;
    var tmp;
    for (i in r.OBJECTS) {
        if (!r.OBJECTS.hasOwnProperty(i))continue;
        var o = r.OBJECTS[i];
        if (o instanceof Group) {
            // split the label to two, NAME and address
            yy.result('  network ' + o.getName() + '{');
            if (o.getLabel() != "")
                yy.result('    address="' + o.getLabel() + '"');
            for (var j in o.OBJECTS) {
                if (!o.OBJECTS.hasOwnProperty(j))continue;
                var z = o.OBJECTS[j];
                tmp = getAttrFmt(z, 'color', ',color="{0}"') + getShape(shapes.actdiag, z.shape, ',shape="{0}"') + getAttrFmt(z, 'label', ',address="{0}"');
                if (tmp.trim() != "")
                    tmp = "[" + tmp.trim().substring(1) + "]";
                yy.result("    " + z.getName() + tmp + ';');
            }
            // find if there are ANY links that have this GROUP as participant!
            for (var il in yy.LINKS) {
                if (!yy.LINKS.hasOwnProperty(il))continue;
                var l = yy.LINKS[il];
                tmp = getAttrFmt(l, 'label', '[address="{0}"]');
                if (l.left == o) {
                    yy.result("  " + l.right.getName() + tmp + ";");
                }
                if (l.right == o) {
                    yy.result("  " + l.left.getName() + tmp + ";");
                }
            }
            yy.result("  }");
        } else {
            // ICON does not work, using background
            tmp = getAttrFmt(o, 'color', ',color="{0}"') + getAttrFmt(o, 'image', ',background="icons{0}"') + getShape(shapes.actdiag, o.shape, ',shape="{0}"') + getAttrFmt(o, 'label', ',label="{0}"');
            if (tmp.trim() != "")
                tmp = "[" + tmp.trim().substring(1) + "]";
            yy.result("    " + o.getName() + tmp + ';');
        }
    }
    for (i in yy.LINKS) {
        if (!yy.LINKS.hasOwnProperty(i))continue;
        var l1 = yy.LINKS[i];
        if (l1.left instanceof Group || l1.right instanceof Group)
            continue;
        yy.result(l1.left.getName() + " -- " + l1.right.getName() + ";");
    }
    yy.result("}");
}
function plantuml_sequence(yy) {
    var processANode = function (o,sbgraph) {
        var nattrs = [];
        var styles = [];
        // getAttrFmt(o, 'color', 'fillcolor="{0}"',nattrs);
        // getAttrFmt(o,'color','filled',styles);
        getAttrFmt(o, 'style', '{0}', styles);
        if (styles.length > 0) {
            if (styles.join("").indexOf('singularity') !== -1) {
                // invis node is not singularity!, circle with minimal
                // width/height IS!
                nattrs.push('shape="circle"');
                nattrs.push('label=""');
                nattrs.push("width=0.01");
                nattrs.push("weight=0.01");
            } else {
                nattrs.push('style="' + styles.join(",") + '"');
            }
        }
        getAttrFmt(o, 'image', 'image="icons{0}"', nattrs);
        getAttrFmt(o, 'textcolor', 'fontcolor="{0}"', nattrs);
        var r = getShape(shapes.digraph, o.shape, 'shape="{0}"');
        if (r) {
            nattrs.push(r);
        }
        var t = "";
        if (nattrs.length > 0)
            t = "[" + nattrs.join(",") + "]";
        //yy.result(indent("participant " + getAttrFmt(o, 'label', '"{0}" as') + " " + o.getName() + t));
        output(yy, "participant {0} {1} {2}".format(
			    getAttrFmt(o, 'label', '"{0}" as'),
			    o.getName(),
			    t));
    };

    var r = getGraphRoot(yy);
    if (r.getVisualizer()) {
        outputFmt(yy, "/* render: {0} */",[r.getVisualizer()])
    }
    output(yy, "@startuml");
    output(yy, "autonumber",true);
    /*
     * if (r.getDirection() === "portrait") { output(yy, indent("rankdir=LR;")); }
     * else { output(yy, indent("rankdir=TD;")); }
     */
    // This may FORWARD DECLARE a node...which creates problems with coloring
    var s = r.getStart();
    if (s != undefined && s != "") {
        var fwd = getNode(yy, s);
        processANode(fwd, false);
    }
    // print only NON PRINTED container links. If first non printed link is NOT
    // for this container, break out immediately
    // this is to emulate ORDERED nodes of plantuml
    // (node=edge,node,link.group...all in order for this fucker)
    var printLinks = function printLinks(container, sbgraph) {
        for (var i in yy.LINKS) {
            if (!yy.LINKS.hasOwnProperty(i))continue;
            var l = yy.LINKS[i];
            if (l.printed)
                continue;
            // if container given, print ONLY THOSE links that match this
            // container!
            if (l.container !== container)
                break;
            l.printed = true;
            //var attrs = [];
            var note = "";
            var label = getAttr(l, 'label');
            if (label) {
                if (label.indexOf("::") !== -1) {
                    label = label.split("::");
                    note = label[1].trim();
		    label=label[0].trim();
                }
            }
            var color = getAttrFmt(l, 'color', '[{0}]').trim();
            // getAttrFmt(l, ['textcolor','color'] ,'fontcolor="{0}"',attrs);
            var lt;
            var lr = l.right;
            var ll = l.left;

            // output(yy, indent("//"+lr));
            if (lr instanceof Group) {
                // just pick ONE Node from group and use lhead
                // TODO: Assuming it is Node (if Recursive groups implemented,
                // it could be smthg else)
                // attrs.push(" lhead=cluster_" + lr.getName());
                // TODO:
                lr = lr.OBJECTS[0];
                if (lr == undefined) {
                    // TODO:Bad thing, EMPTY group..add one invisible node
                    // there...
                    // But should add already at TOP
                }
            }
            if (ll instanceof Group) {
                // attrs.push(" ltail=cluster_" + ll.getName());
                // TODO:
                ll = ll.OBJECTS[0];
                if (ll == undefined) {
                    // Same as above
                }
            }
            // TODO:Assuming producing DIGRAPH
            // For GRAPH all edges are type --
            // but we could SET arrow type if we'd like
            if (l.linkType.indexOf("/") !== -1) {
                // TODO: Somehow denote better this "quite does not reach"
                // even though such an edge type MAKES NO SENSE in a graph
                // attrs.push('arrowhead="tee"');
                // TODO:
            }
            var dot = false;
            var dash = false;
            //var broken = false;
            if (l.linkType.indexOf(".") !== -1) {
                dot = true;
            } else if (l.linkType.indexOf("-") !== -1) {
                dash = true;
            } else if (l.linkType.indexOf("/") !== -1) {
                // attrs.push("failed");
                // TODO:
            }
            var swap = false;
            if (l.linkType.indexOf("<") !== -1 && l.linkType.indexOf(">") !== -1) {
                lt = (dot ? "-" : "") + "-" + color + ">";
                swap = true;
            } else if (l.linkType.indexOf("<") !== -1) {
                var tmp = ll;
                ll = lr;
                lr = tmp;
                lt = (dot ? "-" : "") + "-" + color + ">";
            } else if (l.linkType.indexOf(">") !== -1) {
                lt = (dot ? "-" : "") + "-" + color + ">";
            } else if (dot) {
                // dotted
                output(yy, getAttrFmt(l, 'label', '...{0}...'));
                continue;
            } else if (dash) {
                // dashed
                output(yy, getAttrFmt(l, 'label', '=={0}=='));
                continue;
            } else {
                // is dotted or dashed no direction
                lt = "-" + color + ">";
                // attrs.push("dir=none");
            }
            var t = "";
            // if (attrs.length>0)
            // t = "[" + attrs.join(",") + "]";
            if (label)
                label = ":" + label;
            else
                label = "";
            output(yy, ll.getName() + lt + lr.getName() + t + label);
            if (swap)
                output(yy, lr.getName() + lt + ll.getName() + t + label);
            if (sbgraph){
                if (!lr.active){
                    output(yy, "activate "+ lr.getName(),true);
                    lr.active=true;
                }else{
                    ll.active=false;
		    output(false);
                    output(yy, "deactivate "+ ll.getName());
                }
            }else{
                if (ll.active){
                    ll.active=false;
		    output(false);
                    output(yy, "deactivate "+ ll.getName());   
                }
            }
            if (note != "") {
                output(yy, "note over " + lr.getName());
                outputFmt(yy, note.replace(/\\n/g, "\n"));
                output(yy, "end note");
            }
        }
    };

    var traverseObjects = function traverseObjects(r, isSubGraph) {
        // Dump this groups participants first...
        var i;
        var o;
        for (i in r.OBJECTS) {
            if(!r.OBJECTS.hasOwnProperty(i))continue;
            o = r.OBJECTS[i];
            if (o instanceof Node)
                processANode(o, isSubGraph);
        }
        printLinks(r, isSubGraph);
        for (i in r.OBJECTS) {
            if(!r.OBJECTS.hasOwnProperty(i))continue;
            o = r.OBJECTS[i];
            if (o instanceof Group) {
                // TODO:
                // Group name,OBJECTS,get/setEqual,toString
                var processAGroup = function (o) {
                    debug('processAGroup:'+JSON.stringify(o));
                    var cond = getAttr(o, 'conditional');
                    var nodeIsSubGraph = getAttr(o, 'isSubGraph');
                    if (cond) {
                        if (cond == "if")
                            cond = "alt";
                        else if (cond == "elseif")
                            cond = "else";
                        else if (cond == "else")
                            cond = "else";
                        else if (cond == "endif")
                            cond = "end";
                        output(yy, cond + ' ' + o.getLabel());
                    } else {
                        cond="";//cond = "ref";
                    }
                    if (o.getColor() !== undefined) {
                        output(yy, "style=filled;");
                        output(yy, getAttrFmt(o, 'color',
                            '   color="{0}";\n'));
                    }
                    traverseObjects(o, nodeIsSubGraph);
                    printLinks(o);
                    // output(yy, indent("}//end of " + o.getName()));
                }(o);
            } else if (!o instanceof Node) {
                throw new Error("Not a node nor a group, NOT SUPPORTED");
            }
        }
    }(r,false);
    printLinks(r);
    output(false);
    output(yy, "@enduml");
}
function sankey(yy) {
    var tree;
    function addNode(l, r) {
	if (tree === undefined) {
	    tree = new TreeNode(l);
	}
	if (!(l instanceof Node)) return;
	var cl = findNode(tree,l);
	if (cl===undefined){
	    throw new Error('Left node ('+l.name+') not found from tree');
	}
	if (undefined === findNode(tree,r) && (r instanceof Node)){
	    debug('Add '+r.name+' as child of '+cl.data.name+" co "+r.container);
	    cl.CHILDREN.push(new TreeNode(r));
	}
    }

    //debug(JSON.stringify(yy.LINKS));
    /**
     * For a dendrogram we're not interested in nodes
     * just edges(for now!)
     */
    traverseLinks(yy, function(l) {
	//debug('link node '+l.left.name+' to '+l.right.name);
	addNode(l.left, l.right);
    });

    //output(yy,'{',true);
    traverseTree(tree,function (t, isLeaf, hasSibling) {
	if (isLeaf){
	    comma='';
	    if (hasSibling)
		comma=',';
	    output(yy,'{"name": "'+t.data.name+'", "size": 1}'+comma);
	}else{
	    output(yy,'{',true);
	    output(yy,'"name": "'+t.data.name+'",');
	}
    },function(t){
	output(yy,'"children": [',true);
    },function(t, hasNextSibling){
	output(false);
	output(yy,']',false);
	if (hasNextSibling){
	    output(yy,'},');
	}else{
	    output(yy,'}');
	}
    });
    output(false);
}
function seqdiag(yy) {
    yy.result("seqdiag {");
    yy.result("autonumber = True;");
    // quite fucked up life line activations and no control over..skip
    // it,shrimpy!
    yy.result(" activation = none;");
    var r = getGraphRoot(yy);
    var i;
    // print out all node declarations FIRST (if any)
    for ( i in r.OBJECTS) {
        if (!r.OBJECTS.hasOwnProperty(i))continue;
        var o = r.OBJECTS[i];
        if (o instanceof Group) {
            yy.result(' /*' + o.getName() + getAttrFmt(o, 'label', ' {0}*/'));
            for (var j in o.OBJECTS) {
                if (!o.OBJECTS.hasOwnProperty(j))continue;
                var z = o.OBJECTS[j];
                // no color support either..
                var s = getAttrFmt(z, 'style', ',style={0}') + getAttrFmt(z, 'label', ',label="{0}"');
                if (s.trim() != "")
                    s = "[" + s.trim().substring(1) + "]";
                yy.result(z.getName() + s + ";");
            }
        } else if (o instanceof Node) {
            var s1 = getAttrFmt(o, 'style', ',style={0}') + getAttrFmt(o, 'label', ',label="{0}"') + getAttrFmt(o, 'color', ',color="{0}"');
            if (s1.trim() != "")
                s1 = "[" + s1.trim().substring(1) + "]";
            yy.result(o.getName() + s1 + ";");
        }
    }
    for (i in yy.LINKS) {
        if (!yy.LINKS.hasOwnProperty(i))continue;
        var l = yy.LINKS[i];
        var attrs = [];
        var lt="";
        var lr = l.right;
        var ll = l.left;

        var color = getAttr(l, 'color');
        if (color) {
            attrs.push('color="' + color + '"');
        }
        var label = getAttr(l, 'label');
        if (label) {
            if (label.indexOf("::") !== -1) {
                label = label.split("::");
                attrs.push('note="' + label[1].trim() + '"');
                attrs.push('label="' + label[0].trim() + '"');
            } else {
                attrs.push('label="' + label.trim() + '"');
            }
        }
        if (lr instanceof Group) {
            // just pick ONE Node from group and use lhead
            // TODO: Assuming it is Node (if Recursive groups implemented, it
            // could be smthg else)
            lt += " lhead=cluster_" + lr.getName();
            lr = lr.OBJECTS[0];
            if (lr == undefined) {
                // TODO:Bad thing, EMPTY group..add one invisible node there...
                // But should add already at TOP
            }
        }
        // TODO:Assuming producing DIGRAPH
        // For GRAPH all edges are type --
        // but we could SET arrow type if we'd like
        var rightName = lr.getName();
        var dot = false;
        var dash = false;
        //var broken = false;
        if (l.linkType.indexOf(".") !== -1) {
            dot = true;
        } else if (l.linkType.indexOf("-") !== -1) {
            dash = true;
        } else if (l.linkType.indexOf("/") !== -1) {
            attrs.push("failed");
        }
        if (l.linkType.indexOf("<") !== -1 && l.linkType.indexOf(">") !== -1) {
            // Broadcast type (<>)
            // Alas not supported...
            // HMh..since one could use the === as broadcast
            // a<>b would be BETTER served as autoreturn edge
            // But I'd need to GUESS a new broadcast then..
            // hm.. solve a<>a is broadcast, where as
            // a<>b (any else than node itself) is autoreturn
            if (lr == ll) {
                yy.result(getAttrFmt(l, 'label', '===BROADCAST:{0}==='));
                continue;
            }
            lt = '=>';
        } else if (l.linkType.indexOf("<") !== -1) {
            if (dot)
                lt = "<--";
            else if (dash)
                lt = "<<--";
            else
                lt = "<-";
            rightName = lr.getName();
        } else if (l.linkType.indexOf(">") !== -1) {
            if (dot)
                lt = "-->";
            else if (dash)
                lt = "-->>";
            else
                lt = "->";
        } else if (dot) {
            // dotted
            yy.result(getAttrFmt(l, 'label', '...{0}...'));
            continue;
        } else if (dash) {
            // dashed
            yy.result(getAttrFmt(l, 'label', '==={0}==='));
            continue;
        } else {
            yy.result("ERROR: SHOULD NOT HAPPEN");
        }
        // MUST HAVE whitespace at both sides of the "arrow"
        yy.result(ll.getName() + " " + lt + " " + rightName + "[" + attrs.join(",") + "];");
    }
    yy.result("}");
}
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {"flex":true,"case-insensitive":true},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
/*could have a codeblock here*/
collectNextNode=undefined;
function haistvittu(t) {
	//FUCKSAKE! unput is broken, fixed MONTH ago, not seen in npm..fuck fuck
	// https://github.com/zaach/jison/pull/135
	//I CANNOT see it in npm install, and it is NOT seen in jison master branch, but jison-lex..does not show it EITHER
	//but PR merged 3 months ago!WTF..Manually fixed to
	//  nano /usr/local/share//npm/lib/node_modules/jison/node_modules/jison-lex/regexp-lexer.js
	//  nano /usr/local/share//npm/lib/node_modules/jison-lex/regexp-lexer.js
        var c=t.input();
        if (c==":"){
        	var c1=t.input();
                var c2=t.input();
                if (c1.match(/[ns]/i) && c2.match(/[ew]/i)
                	|| (c1.match(/[ensw]/i) && (c2.match(/\s/) || !c2.match(/A-Za-z0-9_/)))){
                        //console.log("compass "+c+c1+c2);
                        t.unput(c2);
                        t.unput(c1);
                        t.unput(c);
                        return 'NAME';
                }
                //console.log("somethign else");
                //read as long as A-Z0-9_
                while(true){
                	var cz=t.input();
                        if (!cz.match(/[A-Za-z_0-9]/i)) {
                        	if (!cz.match(/\n/)) t.unput(cz);
                                break;
                        }
                }
                return 'NAME';
        }else{
        	t.unput(c);
                return 'NAME';
        }
}


var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:return 57;
break;
case 1:return 8;
break;
case 2:return 43;
break;
case 3:return 'IF_CLAUSE';
break;
case 4:return 44;
break;
case 5:return 45;
break;
case 6:return 46;
break;
case 7:return 30;
break;
case 8:return 30;
break;
case 9:return 10;
break;
case 10:return 54;
break;
case 11:return 19;
break;
case 12:return 22;
break;
case 13:this.begin('INITIAL');return 51;
break;
case 14:/*skip*/
break;
case 15:/* skip WS */
break;
case 16:/*skip for now*/
break;
case 17:return 37;
break;
case 18:return 20;
break;
case 19:return 40;
break;
case 20:return 41;
break;
case 21:return 38;
break;
case 22:return 39;
break;
case 23:return 42;
break;
case 24:return 7;
break;
case 25:return 33;
break;
case 26:return 36;
break;
case 27:return 32;
break;
case 28:return 31;
break;
case 29:return 52;
break;
case 30: this.begin('GROUP');return 47;
break;
case 31:return 53;
break;
case 32:return 34;
break;
case 33:return 35;
break;
case 34:return 25;
break;
case 35:return 56;
break;
case 36:return 55;
break;
case 37:return haistvittu(this);
break;
case 38:return 58;
break;
case 39:return 'NUMBER';
break;
case 40:return 5;
break;
case 41:console.log(yy_.yytext);
break;
}
},
rules: [/^(?:"[^"]+")/i,/^(?:\$\([^)]+\))/i,/^(?:(if\s+.*then(?=\n)))/i,/^(?:{IF_CLAUSE})/i,/^(?:(else\s*if\s+.*then(?=\n)))/i,/^(?:(else(?=\n)))/i,/^(?:(end\s*if(?=\n)))/i,/^(?:(;[^\n]+))/i,/^(?:(;[^\n]+(\n)))/i,/^(?:(actor|beginpoint|box|circle|cloud|condition|database|default|diamond|dots|doublecircle|ellipse|endpoint|input|loopin|loopout|mail|minidiamond|minisquare|note|record|roundedbox|square|terminator|loop|loopend|loopstart|rect|rectangle\b))/i,/^(?:(dotted|dashed|solid|bold|rounded|diagonals|invis|singularity\b))/i,/^(?:(\())/i,/^(?:(\)))/i,/^(?:[\n])/i,/^(?:[ \t]+)/i,/^(?:\s+)/i,/^(?:\(|\))/i,/^(?:(^\/\/[^\n]*))/i,/^(?:(,))/i,/^(?:link color)/i,/^(?:link textcolor|link text color)/i,/^(?:node color)/i,/^(?:node textcolor|node text color)/i,/^(?:group color)/i,/^(?:(#[A-Fa-f0-9]{6}))/i,/^(?:^(landscape|horizontal|lr))/i,/^(?:^(portrait|vertical|td))/i,/^(?:equal)/i,/^(?:shape)/i,/^(?:group end|\})/i,/^(?:group|\{)/i,/^(?:start)/i,/^(?:generator)/i,/^(?:visualizer)/i,/^(?:<\/|\/>|<\.>|<->|<>|<-|<\.|<|->|\.>|>|-|\.)/i,/^(?:(\/[A-Za-z0-9]+\.png\b))/i,/^(?:(:(nw|ne|n|sw|se|s|e|w)))/i,/^(?:([A-Za-z][A-Za-z_0-9]*))/i,/^(?:([A-Za-z][A-Za-z_0-9]*))/i,/^(?:([0-9])+)/i,/^(?:$)/i,/^(?:.)/i],
conditions: {"GROUP":{"rules":[1,7,13,14,24,38],"inclusive":false},"INITIAL":{"rules":[0,1,2,3,4,5,6,8,9,10,11,12,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,39,40,41],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}